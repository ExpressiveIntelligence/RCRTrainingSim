<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Step</name>
    </assembly>
    <members>
        <member name="T:Step.Cons">
            <summary>
            LISP-style cons cells for lists.
            </summary>
        </member>
        <member name="F:Step.Cons.First">
            <summary>
            First element of the list
            </summary>
        </member>
        <member name="F:Step.Cons.Rest">
            <summary>
            Rest of the list
            </summary>
        </member>
        <member name="F:Step.Cons.Empty">
            <summary>
            Represents the empty list
            </summary>
        </member>
        <member name="M:Step.Cons.#ctor(System.Object,Step.Cons)">
            <summary>
            Make a list with a new element at a beginning
            </summary>
        </member>
        <member name="M:Step.Cons.GetEnumerator">
            <summary>
            Enumerates the elements of the list
            </summary>
        </member>
        <member name="M:Step.Cons.ToString">
            <inheritdoc />
        </member>
        <member name="M:Step.Cons.CopyTo(System.Array,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Step.Cons.Count">
            <inheritdoc />
        </member>
        <member name="P:Step.Cons.SyncRoot">
            <inheritdoc />
        </member>
        <member name="P:Step.Cons.IsSynchronized">
            <inheritdoc />
        </member>
        <member name="M:Step.Cons.Add(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Step.Cons.Contains(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Step.Cons.CopyTo(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Step.Cons.Clear">
            <inheritdoc />
        </member>
        <member name="M:Step.Cons.IndexOf(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Step.Cons.Insert(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Step.Cons.Remove(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Step.Cons.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Step.Cons.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Step.Cons.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Step.Cons.IsFixedSize">
            <inheritdoc />
        </member>
        <member name="T:Step.EnvironmentOption">
            <summary>
            Hook used to allow the surrounding environment (i.e. repl, game, server code) respond to
            environment-specific requests.  If a request is irrelevant to a given kind of environment,
            the environment should ignore it rather than throw an exception.
            </summary>
        </member>
        <member name="E:Step.EnvironmentOption.Handler">
            <summary>
            Handler(s) for options for the current environment.
            A given handler should ignore any option calls it doesn't know how to handle
            and only throw an exception on a truly invalid call.
            </summary>
        </member>
        <member name="M:Step.EnvironmentOption.Handle(System.String,System.Object[])">
            <summary>
            Call the surrounding environment code to handle the specified option
            </summary>
        </member>
        <member name="T:Step.FormattingOptions">
            <summary>
            Used by TextUtilities.Untokenize to regenerate a string from the tokens generated by the Step code.
            </summary>
        </member>
        <member name="F:Step.FormattingOptions.DefaultTokenFilters">
            <summary>
            Default token filters to use.
            </summary>
        </member>
        <member name="F:Step.FormattingOptions.Default">
            <summary>
            Default formatting options
            </summary>
        </member>
        <member name="F:Step.FormattingOptions.Capitalize">
            <summary>
            If true, capitalize words after a sentence-terminating period.
            </summary>
        </member>
        <member name="F:Step.FormattingOptions.FrenchSpacing">
            <summary>
            If true, include two spaces after a sentence-terminating period rather than one.
            </summary>
        </member>
        <member name="F:Step.FormattingOptions.LineSeparator">
            <summary>
            Text to mark the end of a line
            </summary>
        </member>
        <member name="F:Step.FormattingOptions.ParagraphMarker">
            <summary>
            Text marking the end of a paragraph
            </summary>
        </member>
        <member name="F:Step.FormattingOptions.SuppressLeadingVerticalSpace">
            <summary>
            Ignore paragraph and newline marks at the beginning of the output
            </summary>
        </member>
        <member name="F:Step.FormattingOptions.TokenFilters">
            <summary>
            TokenFilters to apply during output
            </summary>
        </member>
        <member name="P:Step.Interpreter.BranchingStep.Callees">
            <inheritdoc />
        </member>
        <member name="P:Step.Interpreter.BranchingStep.Calls">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.DeterministicTextGenerator">
            <summary>
            A primitive that deterministically maps inputs to output text
            </summary>
        </member>
        <member name="M:Step.Interpreter.DeterministicTextGenerator.#ctor(System.String,System.Func{System.Collections.Generic.IEnumerable{System.String}})">
            <summary>
            A primitive that deterministically maps inputs to output text
            </summary>
            <param name="name">Name of primitive</param>
            <param name="implementation">Delegate to implement the mapping</param>
        </member>
        <member name="M:Step.Interpreter.DeterministicTextGenerator.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.DeterministicTextGenerator`1">
            <summary>
            A primitive that deterministically maps inputs to output text
            </summary>
        </member>
        <member name="M:Step.Interpreter.DeterministicTextGenerator`1.#ctor(System.String,System.Func{`0,System.Collections.Generic.IEnumerable{System.String}})">
            <summary>
            A primitive that deterministically maps inputs to output text
            </summary>
            <param name="name">Name of primitive</param>
            <param name="implementation">Delegate to implement the mapping</param>
        </member>
        <member name="M:Step.Interpreter.DeterministicTextGenerator`1.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.DeterministicTextGenerator`2">
            <summary>
            A primitive that deterministically maps inputs to output text
            </summary>
        </member>
        <member name="M:Step.Interpreter.DeterministicTextGenerator`2.#ctor(System.String,System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.String}})">
            <summary>
            A primitive that deterministically maps inputs to output text
            </summary>
            <param name="name">Name of primitive</param>
            <param name="implementation">Delegate to implement the mapping</param>
        </member>
        <member name="M:Step.Interpreter.DeterministicTextGenerator`2.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.DeterministicTextGeneratorMetaTask">
            <summary>
            A primitive that deterministically maps inputs to output text
            </summary>
        </member>
        <member name="M:Step.Interpreter.DeterministicTextGeneratorMetaTask.#ctor(System.String,System.Func{System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,System.Collections.Generic.IEnumerable{System.String}})">
            <summary>
            A primitive that deterministically maps inputs to output text
            </summary>
            <param name="name">Name of primitive</param>
            <param name="implementation">Delegate to implement the mapping</param>
        </member>
        <member name="M:Step.Interpreter.DeterministicTextGeneratorMetaTask.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.DeterministicTextMatcher">
            <summary>
            A primitive that generates/matches its argument as fixed text
            </summary>
        </member>
        <member name="M:Step.Interpreter.DeterministicTextMatcher.#ctor(System.String,System.Func{System.Object,System.String[]})">
            <summary>
            Make a new primitive that generates/matches its argument as text, and succeeds once
            </summary>
            <param name="name">Name of the primitive</param>
            <param name="renderer">Procedure to map argument to desired text.</param>
        </member>
        <member name="M:Step.Interpreter.DeterministicTextMatcher.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.FluentUpdateStep">
            <summary>
            A step that updates a fluent
            </summary>
        </member>
        <member name="F:Step.Interpreter.FluentUpdateStep.Updates">
            <summary>
            The updates made by this step
            </summary>
        </member>
        <member name="T:Step.Interpreter.GeneralPredicateBase">
            <summary>
            A general unary predicate
            Takes one argument, which can be instantiated or not
            Can succeed or fail an number of times
            Cannot access or modify global state
            </summary>
        </member>
        <member name="F:Step.Interpreter.GeneralPredicateBase.EmptyBindingListArray">
            <summary>
            A statically allocated empty binding list for implementations that don't need to bind anything.
            Saves a little bit of memory allocation.
            </summary>
        </member>
        <member name="M:Step.Interpreter.GeneralPredicateBase.Iterator(System.Object[],Step.Interpreter.BindingEnvironment)">
            <summary>
            Enumerates the non-deterministic solutions for this particular call to the predicate
            </summary>
            <param name="args">Arguments in the call</param>
            <param name="e">Binding environment</param>
            <returns></returns>
        </member>
        <member name="M:Step.Interpreter.GeneralPredicateBase.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="M:Step.Interpreter.GeneralPredicateBase.#ctor(System.String,System.Nullable{System.Int32})">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.GeneralPredicate`1">
            <summary>
            A general unary predicate
            Takes one argument, which can be instantiated or not
            Can succeed or fail an number of times
            Cannot access or modify global state
            </summary>
        </member>
        <member name="M:Step.Interpreter.GeneralPredicate`1.#ctor(System.String,System.Func{`0,System.Boolean},System.Func{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            A general unary predicate
            Takes one argument, which can be instantiated or not
            Can succeed or fail an number of times
            Cannot access or modify global state
            </summary>
            <param name="name">Name of the primitive</param>
            <param name="inMode">Implementation of the predicate for when the argument is instantiated</param>
            <param name="outMode">Implementation of the predicate for when the argument is not instantiated</param>
        </member>
        <member name="M:Step.Interpreter.GeneralPredicate`1.FromList(System.String,System.Collections.Generic.IList{`0})">
            <summary>
            Make a unary predicate from an IList.
            List should not be modified after this call.
            </summary>
            <param name="name">Name for the predicate</param>
            <param name="list">List containing all elements</param>
            <returns>Predicate</returns>
        </member>
        <member name="M:Step.Interpreter.GeneralPredicate`1.FromListRandomized(System.String,System.Collections.Generic.IList{`0})">
            <summary>
            Make a unary predicate from an IList.  Enumerates elements using BadShuffle.
            List should not be modified after this call.
            </summary>
            <param name="name">Name for the predicate</param>
            <param name="list">List containing all elements</param>
            <returns>Predicate</returns>
        </member>
        <member name="M:Step.Interpreter.GeneralPredicate`1.Iterator(System.Object[],Step.Interpreter.BindingEnvironment)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.GeneralPredicate`2">
            <summary>
            A general unary predicate
            Takes one argument, which can be instantiated or not
            Can succeed or fail an number of times
            Cannot access or modify global state
            </summary>
        </member>
        <member name="M:Step.Interpreter.GeneralPredicate`2.#ctor(System.String,System.Func{`0,`1,System.Boolean},System.Func{`0,System.Collections.Generic.IEnumerable{`1}},System.Func{`1,System.Collections.Generic.IEnumerable{`0}},System.Func{System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}}})">
            <summary>
            A general unary predicate
            Takes one argument, which can be instantiated or not
            Can succeed or fail an number of times
            Cannot access or modify global state
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="inInMode">Implementation of the predicate for when both arguments are instantiated</param>
            <param name="inOutMode">Implementation for when the first argument is instantiated and the second isn't</param>
            <param name="outInMode">Implementation for when only the second argument is instantiated</param>
            <param name="outOutMode">Implementation for when neither argument is instantiated</param>
        </member>
        <member name="M:Step.Interpreter.GeneralPredicate`2.Iterator(System.Object[],Step.Interpreter.BindingEnvironment)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.GeneralNAryPredicate">
            <summary>
            Most general interface for writing predicates.
            Does no argument checking, and implementation is a mapping from arglists to an enumerations
            of arrays to unify the arglist with.
            </summary>
        </member>
        <member name="M:Step.Interpreter.GeneralNAryPredicate.#ctor(System.String,System.Func{System.Object[],System.Collections.Generic.IEnumerable{System.Object[]}})">
            <summary>
            Create a general primitive predicate.
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="implementation">Mapping from arguments for the predicate to arrays with which to unify it.
            Returning the empty sequence means failure,
            but returning multiple arglists means the predicate can succeed multiple times.
            </param>
        </member>
        <member name="M:Step.Interpreter.GeneralNAryPredicate.Iterator(System.Object[],Step.Interpreter.BindingEnvironment)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.GeneralPrimitive">
            <summary>
            The most general version of a primitive task.
            This exposes the internal call structure of the interpreter, so avoid using it unless you have to.
            </summary>
        </member>
        <member name="T:Step.Interpreter.GeneralPrimitive.Implementation">
            <summary>
            Implementation of primitive in terms of the general internal call interface used by the interpreter.
            Don't use this unless you know what you're doing.
            </summary>
            <param name="args">Raw, unevaluated arguments to the task</param>
            <param name="o">Partial output accumulated so far</param>
            <param name="e">Binding environment to use</param>
            <param name="predecessor">Frame of the call that most recently succeeded</param>
            <param name="k">Continuation to call when successful</param>
        </member>
        <member name="M:Step.Interpreter.GeneralPrimitive.#ctor(System.String,Step.Interpreter.GeneralPrimitive.Implementation)">
            <summary>
            Make a new primitive task based on an delegate to implement it.
            </summary>
            <param name="name">Name of the task to be printed by the pretty printer</param>
            <param name="implementation">Delegate that implements the task</param>
        </member>
        <member name="M:Step.Interpreter.GeneralPrimitive.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.NondeterministicTextGenerator">
            <summary>
            A primitive task that generates text and succeeds a variable number of times (possibly not at all)
            </summary>
        </member>
        <member name="M:Step.Interpreter.NondeterministicTextGenerator.#ctor(System.String,System.Func{System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.String}}})">
            <summary>
            A primitive task that generates text and succeeds a variable number of times (possibly not at all)
            </summary>
            <param name="name">Name of the primitive</param>
            <param name="implementation">C# code to implement the primitive</param>
        </member>
        <member name="M:Step.Interpreter.NondeterministicTextGenerator.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.NondeterministicTextGenerator`1">
            <summary>
            A primitive task that generates text and succeeds a variable number of times (possibly not at all)
            </summary>
        </member>
        <member name="M:Step.Interpreter.NondeterministicTextGenerator`1.#ctor(System.String,System.Func{`0,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.String}}})">
            <summary>
            A primitive task that generates text and succeeds a variable number of times (possibly not at all)
            </summary>
            <param name="name">Name of the primitive</param>
            <param name="implementation">C# code to implement the primitive</param>
        </member>
        <member name="M:Step.Interpreter.NondeterministicTextGenerator`1.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.NondeterministicTextGenerator`2">
            <summary>
            A primitive task that generates text and succeeds a variable number of times (possibly not at all)
            </summary>
        </member>
        <member name="M:Step.Interpreter.NondeterministicTextGenerator`2.#ctor(System.String,System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.String}}})">
            <summary>
            A primitive task that generates text and succeeds a variable number of times (possibly not at all)
            </summary>
            <param name="name">Name of the primitive</param>
            <param name="implementation">C# code to implement the primitive</param>
        </member>
        <member name="M:Step.Interpreter.NondeterministicTextGenerator`2.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimpleFunction`2">
            <summary>
            A predicate that represents a non-invertible function.
            </summary>
            <typeparam name="TIn">Type of function argument</typeparam>
            <typeparam name="TOut">Type of function value</typeparam>
        </member>
        <member name="M:Step.Interpreter.SimpleFunction`2.#ctor(System.String,System.Func{`0,`1})">
            <summary>
            A predicate that represents a non-invertible function.
            </summary>
            <param name="name">Name of the function predicate</param>
            <param name="implementation">C# implementation of the function</param>
        </member>
        <member name="M:Step.Interpreter.SimpleFunction`2.Iterator(System.Object[],Step.Interpreter.BindingEnvironment)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimpleFunction`3">
            <summary>
            A predicate that represents a non-invertible function.
            </summary>
            <typeparam name="TIn1">Type of first argument</typeparam>
            <typeparam name="TIn2">Type of second argument</typeparam>
            <typeparam name="TOut">Type of function value</typeparam>
        </member>
        <member name="M:Step.Interpreter.SimpleFunction`3.#ctor(System.String,System.Func{`0,`1,`2})">
            <summary>
            A predicate that represents a non-invertible function.
            </summary>
            <param name="name">Name of the function predicate</param>
            <param name="implementation">C# implementation of the function</param>
        </member>
        <member name="M:Step.Interpreter.SimpleFunction`3.Iterator(System.Object[],Step.Interpreter.BindingEnvironment)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimpleFunction`4">
            <summary>
            A predicate that represents a non-invertible function.
            </summary>
            <typeparam name="TIn1">Type of first argument</typeparam>
            <typeparam name="TIn2">Type of second argument</typeparam>
            <typeparam name="TIn3">Type of third argument</typeparam>
            <typeparam name="TOut">Type of function value</typeparam>
        </member>
        <member name="M:Step.Interpreter.SimpleFunction`4.#ctor(System.String,System.Func{`0,`1,`2,`3})">
            <summary>
            A predicate that represents a non-invertible function.
            </summary>
            <param name="name">Name of the function predicate</param>
            <param name="implementation">C# implementation of the function</param>
        </member>
        <member name="M:Step.Interpreter.SimpleFunction`4.Iterator(System.Object[],Step.Interpreter.BindingEnvironment)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimpleFunction`5">
            <summary>
            A predicate that represents a non-invertible function.
            </summary>
            <typeparam name="TIn1">Type of first argument</typeparam>
            <typeparam name="TIn2">Type of second argument</typeparam>
            <typeparam name="TIn3">Type of third argument</typeparam>
            <typeparam name="TIn4">Type of fourth argument</typeparam>
            <typeparam name="TOut">Type of function value</typeparam>
        </member>
        <member name="M:Step.Interpreter.SimpleFunction`5.#ctor(System.String,System.Func{`0,`1,`2,`3,`4})">
            <summary>
            A predicate that represents a non-invertible function.
            </summary>
            <param name="name">Name of the function predicate</param>
            <param name="implementation">C# implementation of the function</param>
        </member>
        <member name="M:Step.Interpreter.SimpleFunction`5.Iterator(System.Object[],Step.Interpreter.BindingEnvironment)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimpleFunction`6">
            <summary>
            A predicate that represents a non-invertible function.
            </summary>
            <typeparam name="TIn1">Type of first argument</typeparam>
            <typeparam name="TIn2">Type of second argument</typeparam>
            <typeparam name="TIn3">Type of third argument</typeparam>
            <typeparam name="TIn4">Type of fourth argument</typeparam>
            <typeparam name="TIn5">Type of fifth argument</typeparam>
            <typeparam name="TOut">Type of function value</typeparam>
        </member>
        <member name="M:Step.Interpreter.SimpleFunction`6.#ctor(System.String,System.Func{`0,`1,`2,`3,`4,`5})">
            <summary>
            A predicate that represents a non-invertible function.
            </summary>
            <param name="name">Name of the function predicate</param>
            <param name="implementation">C# implementation of the function</param>
        </member>
        <member name="M:Step.Interpreter.SimpleFunction`6.Iterator(System.Object[],Step.Interpreter.BindingEnvironment)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimpleFunction`7">
            <summary>
            A predicate that represents a non-invertible function.
            </summary>
            <typeparam name="TIn1">Type of first argument</typeparam>
            <typeparam name="TIn2">Type of second argument</typeparam>
            <typeparam name="TIn3">Type of third argument</typeparam>
            <typeparam name="TIn4">Type of fourth argument</typeparam>
            <typeparam name="TIn5">Type of fifth argument</typeparam>
            <typeparam name="TIn6">Type of sixth argument</typeparam>
            <typeparam name="TOut">Type of function value</typeparam>
        </member>
        <member name="M:Step.Interpreter.SimpleFunction`7.#ctor(System.String,System.Func{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            A predicate that represents a non-invertible function.
            </summary>
            <param name="name">Name of the function predicate</param>
            <param name="implementation">C# implementation of the function</param>
        </member>
        <member name="M:Step.Interpreter.SimpleFunction`7.Iterator(System.Object[],Step.Interpreter.BindingEnvironment)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimpleNAryFunction">
            <summary>
            A simple function supporting a variable number of arguments
            All type checking is left to the implementation function
            </summary>
        </member>
        <member name="M:Step.Interpreter.SimpleNAryFunction.#ctor(System.String,System.Func{System.Object[],System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Step.Interpreter.SimpleNAryFunction.Iterator(System.Object[],Step.Interpreter.BindingEnvironment)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimplePredicate">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
        </member>
        <member name="M:Step.Interpreter.SimplePredicate.#ctor(System.String,System.Func{System.Boolean})">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="implementation">Low-level implementation of the predicate</param>
        </member>
        <member name="M:Step.Interpreter.SimplePredicate.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimplePredicate`1">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
        </member>
        <member name="M:Step.Interpreter.SimplePredicate`1.#ctor(System.String,System.Func{`0,System.Boolean})">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="implementation">Low-level implementation of the predicate</param>
        </member>
        <member name="M:Step.Interpreter.SimplePredicate`1.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimplePredicate`2">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
        </member>
        <member name="M:Step.Interpreter.SimplePredicate`2.#ctor(System.String,System.Func{`0,`1,System.Boolean})">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="implementation">Low-level implementation of the predicate</param>
        </member>
        <member name="M:Step.Interpreter.SimplePredicate`2.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimplePredicate`3">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
        </member>
        <member name="M:Step.Interpreter.SimplePredicate`3.#ctor(System.String,System.Func{`0,`1,`2,System.Boolean})">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="implementation">Low-level implementation of the predicate</param>
        </member>
        <member name="M:Step.Interpreter.SimplePredicate`3.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimplePredicate`4">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
        </member>
        <member name="M:Step.Interpreter.SimplePredicate`4.#ctor(System.String,System.Func{`0,`1,`2,`3,System.Boolean})">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="implementation">Low-level implementation of the predicate</param>
        </member>
        <member name="M:Step.Interpreter.SimplePredicate`4.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimplePredicate`5">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
        </member>
        <member name="M:Step.Interpreter.SimplePredicate`5.#ctor(System.String,System.Func{`0,`1,`2,`3,`4,System.Boolean})">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="implementation">Low-level implementation of the predicate</param>
        </member>
        <member name="M:Step.Interpreter.SimplePredicate`5.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.SimpleNAryPredicate">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
        </member>
        <member name="M:Step.Interpreter.SimpleNAryPredicate.#ctor(System.String,System.Func{System.Object[],System.Boolean})">
            <summary>
            A primitive task that implements a deterministic function from arguments to a boolean
            Requires all arguments to be instantiated
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="implementation">Low-level implementation of the predicate</param>
        </member>
        <member name="M:Step.Interpreter.SimpleNAryPredicate.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.Task">
            <summary>
            Base class for objects representing tasks (things user code can call)
            </summary>
        </member>
        <member name="F:Step.Interpreter.Task.Name">
            <summary>
            Name, for debugging purposes
            </summary>
        </member>
        <member name="P:Step.Interpreter.Task.Properties">
            <summary>
            Dictionary of additional user-defined metadata
            </summary>
        </member>
        <member name="F:Step.Interpreter.Task.ArgumentCount">
            <summary>
            Number of arguments required by this task, if fixed.
            </summary>
        </member>
        <member name="F:Step.Interpreter.Task.Arglist">
            <summary>
            Optional documentation of the names of the arguments to the task
            These are here purely for documentation purposes.  They aren't used during the calling sequence.
            </summary>
        </member>
        <member name="P:Step.Interpreter.Task.HasDocumentation">
            <summary>
            This task has documentation metadata
            </summary>
        </member>
        <member name="M:Step.Interpreter.Task.Arguments(System.String[])">
            <summary>
            Adds documentation of the arguments to the task
            </summary>
            <param name="arglist">The names of the arguments</param>
            <returns>The original task</returns>
        </member>
        <member name="F:Step.Interpreter.Task.Description">
            <summary>
            Optional documentation of what the task does
            </summary>
        </member>
        <member name="M:Step.Interpreter.Task.Documentation(System.String)">
            <summary>
            Adds documentation of the description of the task
            </summary>
            <param name="documentation">Description of what the task does</param>
            <returns>The original task</returns>
        </member>
        <member name="F:Step.Interpreter.Task.ManualSection">
            <summary>
            Optional documentation of what section of the manual this should appear in
            </summary>
        </member>
        <member name="M:Step.Interpreter.Task.Documentation(System.String,System.String)">
            <summary>
            Adds documentation of the description of the task
            </summary>
            <param name="manualSection">Section of the manual to place this task in</param>
            <param name="documentation">Description of what the task does</param>
            <returns>The original task</returns>
        </member>
        <member name="M:Step.Interpreter.Task.#ctor(System.String,System.Nullable{System.Int32})">
            <summary>
            Initialize name of task
            </summary>
        </member>
        <member name="M:Step.Interpreter.Task.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <summary>
            Call this task with the specified arguments
            </summary>
            <param name="arglist">Task arguments</param>
            <param name="output">Output accumulated so far</param>
            <param name="env">Binding environment</param>
            <param name="predecessor">Most recently succeeded MethodCallFrame</param>
            <param name="k">Continuation</param>
            <returns>True if task succeeded and continuation succeeded</returns>
            <exception cref="T:Step.Interpreter.CallFailedException">If the task fails</exception>
        </member>
        <member name="M:Step.Interpreter.Task.ToString">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.IVariableName">
            <summary>
            Base class of objects that name both local variables and global variables
            </summary>
        </member>
        <member name="T:Step.Interpreter.TuplePredicate">
            <summary>
            A predicate implemented by scanning a table of tuples
            Important: "tuple" here means object[], not the Tuple generic type
            </summary>
        </member>
        <member name="P:Step.Interpreter.TuplePredicate.Arity">
            <summary>
            Number of arguments to the predicate
            This must be the same as the length of every tuple.
            </summary>
        </member>
        <member name="F:Step.Interpreter.TuplePredicate.Signature">
            <summary>
            Expected types for each argument
            </summary>
        </member>
        <member name="F:Step.Interpreter.TuplePredicate.indices">
            <summary>
            Index for each argument, or null if that argument isn't indexed
            An index maps a value for the argument to a list of tuples that match it
            </summary>
        </member>
        <member name="F:Step.Interpreter.TuplePredicate.tuples">
            <summary>
            The complete list of all tuples
            </summary>
        </member>
        <member name="F:Step.Interpreter.TuplePredicate.Shuffler">
            <summary>
            Procedure too shuffle tuples, if desired
            </summary>
        </member>
        <member name="M:Step.Interpreter.TuplePredicate.#ctor(System.String,System.Type[],System.Boolean[],System.Collections.Generic.IEnumerable{System.Object[]})">
            <summary>
            Make a new general predicate that is true whenever the arguments match a tuple in the specified set.
            </summary>
            <param name="name">Name to give to the predicate</param>
            <param name="signature">Array of expected types for the arguments.  Use Object if it can be any type</param>
            <param name="indexArgument">Array of Booleans specifying whether to build indices for each argument</param>
            <param name="tuples">Generator for the actual tuples to store</param>
            <exception cref="T:System.ArgumentException">If the signature, indexArgument, or tuple arrays don't all have the same length</exception>
        </member>
        <member name="M:Step.Interpreter.TuplePredicate.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.FunctionalExpressionParser">
            <summary>
            Parser for arithmetic/functional expressions used in set commands.
            TODO: handle right-associative binary operators
            TODO: handle suffix unary operators
            TODO: assumes unary operators are always higher precedence than binary operators, so handle unary operators of lower 
            TODO: handle non-operator functions
            </summary>
        </member>
        <member name="M:Step.Interpreter.FunctionalExpressionParser.Parse(System.Object[],System.Int32,System.String,System.Int32)">
            <summary>
            The actual parser.  This takes an array of tokens and returns a FunctionalExpression
            </summary>
            <param name="tokens">Tokens comprising the functional expression</param>
            <param name="start">Index of the start of the functional expression within the tokens</param>
            <param name="path">Source file this comes from</param>
            <param name="lineNumber">line within the source file</param>
            <returns>The FunctionalExpression denoted by the tokens</returns>
        </member>
        <member name="T:Step.Interpreter.SequenceStep">
            <summary>
            Implements a sequence in which each successive call invokes the next branch
            </summary>
        </member>
        <member name="M:Step.Interpreter.SequenceStep.#ctor(Step.Interpreter.Step[],Step.Interpreter.Step)">
            <summary>
            Makes a step that first calls the first branch, then on successive calls, invokes successive branches.
            </summary>
        </member>
        <member name="M:Step.Interpreter.SequenceStep.Try(Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.Step.Continuation,Step.Interpreter.MethodCallFrame)">
            <summary>
            Run the next branch, or fail if we've run out of branches
            </summary>
        </member>
        <member name="T:Step.Interpreter.StateElement">
            <summary>
            A name for an element of the State, that is, something that can change during the execution of the program
            </summary>
        </member>
        <member name="F:Step.Interpreter.StateElement.Name">
            <summary>
            Name of the dynamic state element.
            </summary>
        </member>
        <member name="F:Step.Interpreter.StateElement.HasDefault">
            <summary>
            True if this state element has a default value
            </summary>
        </member>
        <member name="F:Step.Interpreter.StateElement.DefaultValue">
            <summary>
            Default value of state element if HasDefault is true
            </summary>
        </member>
        <member name="M:Step.Interpreter.StateElement.#ctor(System.String,System.Boolean,System.Object)">
            <summary>
            Make a new StateElement with the specified name
            </summary>
        </member>
        <member name="M:Step.Interpreter.StateElement.ToString">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.ArgumentCountException">
            <summary>
            Signals a task was called with the wrong number of arguments
            </summary>
        </member>
        <member name="M:Step.Interpreter.ArgumentCountException.#ctor(System.Object,System.Int32,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:Step.Interpreter.ArgumentCountException.Check(System.Object,System.Int32,System.Object[])">
            <summary>
            Check if the number of arguments is as expected.  If not, throw an exception.
            </summary>
            <param name="task">Name of task called (used in error message, if necessary)</param>
            <param name="expected">Number of arguments the task should take</param>
            <param name="arglist">Actual arguments passed</param>
            <exception cref="T:Step.Interpreter.ArgumentCountException">When the number of arguments is incorrect.</exception>
        </member>
        <member name="M:Step.Interpreter.ArgumentCountException.CheckAtLeast(System.Object,System.Int32,System.Object[])">
            <summary>
            Check if the number of arguments is as expected.  If not, throw an exception.
            </summary>
            <param name="task">Name of task called (used in error message, if necessary)</param>
            <param name="minArgs">Minimum number of arguments the task should take</param>
            <param name="arglist">Actual arguments passed</param>
            <exception cref="T:Step.Interpreter.ArgumentCountException">When the number of arguments is incorrect.</exception>
        </member>
        <member name="T:Step.Interpreter.ArgumentTypeException">
            <summary>
            Signals a task was called with the wrong kind of argument
            </summary>
        </member>
        <member name="M:Step.Interpreter.ArgumentTypeException.#ctor(System.Object,System.Type,System.Object,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:Step.Interpreter.ArgumentTypeException.Check(System.Object,System.Type,System.Object,System.Object[],System.Boolean)">
            <summary>
            Check the specified argument value is of the right type.  If not, throw exception
            </summary>
            <param name="task">Name of task - used in error message if necessary</param>
            <param name="expected">Type expected</param>
            <param name="actual">Value provided</param>
            <param name="arglist">Full argument list of the task</param>
            <param name="allowUninstantiated">If true, accept an unbound variable as a value</param>
            <exception cref="T:Step.Interpreter.ArgumentTypeException">When value isn't of the expected type</exception>
        </member>
        <member name="M:Step.Interpreter.ArgumentTypeException.Cast``1(System.Object,System.Object,System.Object[])">
            <summary>
            Check the specified argument value is of the right type.
            If so, return the argument cast to the type.  If not, throw exception
            </summary>
            <param name="task">Name of task - used in error message if necessary</param>
            <param name="actual">Value provided</param>
            <param name="arglist">Full argument list of the task</param>
            <exception cref="T:Step.Interpreter.ArgumentTypeException">When value isn't of the expected type</exception>
        </member>
        <member name="T:Step.Interpreter.ArgumentInstantiationException">
            <summary>
            Signals a task was called with an arg bound/unbound when it shouldn't have been
            </summary>
        </member>
        <member name="M:Step.Interpreter.ArgumentInstantiationException.#ctor(System.Object,Step.Interpreter.BindingEnvironment,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:Step.Interpreter.ArgumentInstantiationException.#ctor(System.Object,Step.Interpreter.BindingEnvironment,System.Object[],System.String)">
            <inheritdoc />
        </member>
        <member name="M:Step.Interpreter.ArgumentInstantiationException.Check(System.Object,System.Object,System.Boolean,Step.Interpreter.BindingEnvironment,System.Object[])">
            <summary>
            Check argument and throw instantiation exception if necessary.
            </summary>
        </member>
        <member name="T:Step.Interpreter.BindingEnvironment">
            <summary>
            Represents all information about variable binding at a particular point in execution
            Binding environments are readonly because we have to support backtracking: when we bind
            a variable, we make a new binding environment, so that the old environment still exists
            if we have to backtrack.
            </summary>
        </member>
        <member name="F:Step.Interpreter.BindingEnvironment.Module">
            <summary>
            Module containing bindings of GlobalVariables
            </summary>
        </member>
        <member name="F:Step.Interpreter.BindingEnvironment.Frame">
            <summary>
            MethodCallFrame of this environment
            </summary>
        </member>
        <member name="P:Step.Interpreter.BindingEnvironment.Local">
            <summary>
            Logic variables holding the values of the current method's local variables
            </summary>
        </member>
        <member name="F:Step.Interpreter.BindingEnvironment.Unifications">
            <summary>
            Bindings mapping local variables to their values, or to other local variables
            </summary>
        </member>
        <member name="F:Step.Interpreter.BindingEnvironment.State">
            <summary>
            Bindings mapping global variables to their values, when overriding the Module's values
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.#ctor(Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame)">
            <summary>
            Make a new binding environment based on the specified environment, with the specified change(s)
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.#ctor(Step.Module,Step.Interpreter.MethodCallFrame)">
            <summary>
            Make a new binding environment based on the specified environment, with the specified change(s)
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.#ctor(Step.Interpreter.BindingEnvironment,Step.Interpreter.BindingList{Step.Interpreter.LogicVariable},Step.State)">
            <summary>
            Make a new binding environment based on the specified environment, with the specified change(s)
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.#ctor(Step.Interpreter.BindingEnvironment,Step.Interpreter.StateElement,System.Object)">
            <summary>
            Make a binding environment identical to e but with v bound to newValue
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.#ctor(Step.Module,Step.Interpreter.MethodCallFrame,Step.Interpreter.BindingList{Step.Interpreter.LogicVariable},Step.State)">
            <summary>
            Make a new binding environment with the specified components
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.NewEmpty">
            <summary>
            Make a new binding environment with nothing in it.
            Used for Unit tests.  Don't use this yourself.
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.Resolve(System.Object,Step.Interpreter.BindingList{Step.Interpreter.LogicVariable})">
            <summary>
            Canonicalize a term, i.e. get its value, or reduce it to a logic variable
            if it doesn't have a value yet
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.Resolve(System.Object)">
            <summary>
            Canonicalize a list of terms, i.e. get their values or reduce them to (unbound) logic variables.
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.ResolveList(System.Object[],Step.Interpreter.BindingList{Step.Interpreter.LogicVariable})">
            <summary>
            Canonicalize a list of terms, i.e. get their values or reduce them to (unbound) logic variables.
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.ResolveList(System.Object[])">
            <summary>
            Canonicalize a list of terms, i.e. get their values or reduce them to (unbound) logic variables.
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.Unify(System.Object,System.Object,Step.Interpreter.BindingList{Step.Interpreter.LogicVariable},Step.Interpreter.BindingList{Step.Interpreter.LogicVariable}@)">
            <summary>
            Attempt to unify two terms
            </summary>
            <param name="a">First term</param>
            <param name="b">Other term</param>
            <param name="inUnifications">Substitutions currently in place</param>
            <param name="outUnifications">Substitutions in place after unification, if unification successful</param>
            <returns>True if the objects are unifiable and outUnification holds their most general unifier</returns>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.Unify(System.Object,System.Object,Step.Interpreter.BindingList{Step.Interpreter.LogicVariable}@)">
            <summary>
            Attempt to unify two terms
            </summary>
            <param name="a">First term</param>
            <param name="b">Other term</param>
            <param name="outUnifications">Substitutions in place after unification, if unification successful</param>
            <returns>True if the objects are unifiable and outUnification holds their most general unifier</returns>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.UnifyArrays(System.Object[],System.Object[],Step.Interpreter.BindingList{Step.Interpreter.LogicVariable}@)">
            <summary>
            Unifies the elements of two arrays using this environment's binding list
            </summary>
            <param name="a">First array</param>
            <param name="b">Second array</param>
            <param name="outUnifications">Extended binding list</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.UnifyArrays(System.Object[],System.Object[],Step.Interpreter.BindingEnvironment@)">
            <summary>
            Attempt to unify two arrays of terms
            </summary>
            <param name="a">First array term</param>
            <param name="b">Other array term</param>
            <param name="e">Resulting BindingEnvironment.  This is the same as this BindingEnvironment, but possibly with a longer Unifications list.</param>
            <returns>True if the objects are unifiable and e holds their most general unifier</returns>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.Deref(System.Object)">
            <summary>
            If value is a LogicVariable, follow the chain of substitutions in Unifications to reduce it to its normal form.
            If it's not a logic variable, just returns the value.
            </summary>
            <param name="value">Term</param>
            <returns>Reduced value of term.  Could be a LogicVariable, in which case it reduces to an unbound variable.</returns>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.Deref(System.Object,Step.Interpreter.BindingList{Step.Interpreter.LogicVariable})">
            <summary>
            If value is a LogicVariable, follow the chain of substitutions in Unifications to reduce it to its normal form.
            If it's not a logic variable, just returns the value.
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.CopyTerm(System.Object)">
            <summary>
            Dereference all variables in term
            This behaves identically to Deref except in the case where term is a tuple (i.e. object[]), in which case it
            recursively recopies the array and dereferences its elements
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingEnvironment.TryCopyGround(System.Object,System.Object@)">
            <summary>
            Dereference all variables in term
            If the resulting term has uninstantiated variables, return false.
            </summary>
        </member>
        <member name="T:Step.Interpreter.BindingList`1">
            <summary>
            Represents values of variables of different types.
            In the case of LocalVariables, which can be unified, this might be another variable,
            in which case the bound variable has whatever value the other variable has.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Step.Interpreter.BindingList`1.Variable">
            <summary>
            Variable given a value by this cell of the linked list
            </summary>
        </member>
        <member name="F:Step.Interpreter.BindingList`1.Value">
            <summary>
            Value given to the Variable
            </summary>
        </member>
        <member name="F:Step.Interpreter.BindingList`1.Next">
            <summary>
            Next cell in the binding list
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingList`1.#ctor(`0,System.Object,Step.Interpreter.BindingList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Step.Interpreter.BindingList`1.TryLookup(Step.Interpreter.BindingList{`0},`0,System.Object@)">
            <summary>
            Attempt to find the value of the variable in the bindinglist
            </summary>
            <param name="bindingList">BindingList to check</param>
            <param name="variable">Variable to look for</param>
            <param name="value">Value, if found, or null</param>
            <returns>True if a value was found, otherwise false.</returns>
        </member>
        <member name="M:Step.Interpreter.BindingList`1.Lookup(Step.Interpreter.BindingList{`0},`0,System.Object)">
            <summary>
            Return value of the variable in the (possibly empty) binding list
            </summary>
            <param name="bindingList">List to check</param>
            <param name="v">Variable to look up</param>
            <param name="defaultValue">Default value to return if the variable isn't found</param>
            <returns>Value of variable or defaultValue if not found</returns>
        </member>
        <member name="M:Step.Interpreter.BindingList`1.Lookup(`0,System.Object)">
            <summary>
            Find the value to which the variable is bound
            </summary>
            <param name="v">Variable whose value to look up</param>
            <param name="defaultValue">Value to return if the variable isn't bound in this binding list</param>
            <returns>Value of the variable or defaultValue</returns>
        </member>
        <member name="M:Step.Interpreter.BindingList`1.Bind(`0,System.Object)">
            <summary>
            Make a new binding list with specified additional binding
            USE STATIC VERSION IF ORIGINAL LIST MIGHT BE NULL
            </summary>
        </member>
        <member name="M:Step.Interpreter.BindingList`1.Bind(Step.Interpreter.BindingList{`0},`0,System.Object)">
            <summary>
            Make a new binding list with specified additional binding
            </summary>
        </member>
        <member name="T:Step.Interpreter.Builtins">
            <summary>
            Implementations of built-in, but first-order primitives
            Higher-order primitives are in HigherOrderBuiltins.cs
            </summary>
        </member>
        <member name="M:Step.Interpreter.Builtins.DefineGlobals">
            <summary>
            Add the built-in primitives to the global module.
            </summary>
        </member>
        <member name="T:Step.Interpreter.Call">
            <summary>
            A step that involves calling another task as a subtask
            </summary>
        </member>
        <member name="M:Step.Interpreter.Call.#ctor(System.Object,System.Object[],Step.Interpreter.Step)">
            <summary>
            A step that involves calling a sub-task
            </summary>
            <param name="task">A term whose value is the sub-task to execute</param>
            <param name="args">Terms for the arguments of the call</param>
            <param name="next">Next step in the step chain of whatever method this belongs to</param>
        </member>
        <member name="M:Step.Interpreter.Call.MakeCall(System.Object,Step.Interpreter.Step)">
            <summary>
            Make a new call step to the specified task, with no arguments.
            </summary>
        </member>
        <member name="M:Step.Interpreter.Call.MakeCall(System.Object,System.Object,Step.Interpreter.Step)">
            <summary>
            Make a new call step to the specified task, with the specified argument.
            </summary>
        </member>
        <member name="M:Step.Interpreter.Call.MakeCall(System.Object,System.Object,System.Object,Step.Interpreter.Step)">
            <summary>
            Make a new call step to the specified task, with the specified arguments.
            </summary>
        </member>
        <member name="M:Step.Interpreter.Call.MakeCall(System.Object,System.Object,System.Object,System.Object,Step.Interpreter.Step)">
            <summary>
            Make a new call step to the specified task, with the specified arguments.
            </summary>
        </member>
        <member name="F:Step.Interpreter.Call.Task">
            <summary>
            Term (e.g. variable) representing the task to call
            </summary>
        </member>
        <member name="F:Step.Interpreter.Call.Arglist">
            <summary>
            Terms representing the arguments to the subtask.
            </summary>
        </member>
        <member name="P:Step.Interpreter.Call.SourceText">
            <summary>
            Regenerates an approximation to the source code for this call
            </summary>
        </member>
        <member name="P:Step.Interpreter.Call.Callees">
            <inheritdoc />
        </member>
        <member name="M:Step.Interpreter.Call.Try(Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.Step.Continuation,Step.Interpreter.MethodCallFrame)">
            <summary>
            Attempt to run this task
            </summary>
            <param name="output">Output to which to write text</param>
            <param name="env">Variable binding information</param>
            <param name="k">Continuation to call at the end of this step's step-chain</param>
            <param name="predecessor">Predecessor frame</param>
            <returns>True if this steps, the rest of its step-chain, and the continuation all succeed.</returns>
        </member>
        <member name="P:Step.Interpreter.Call.Source">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.CallException">
            <summary>
            Signals that something went wrong in a call to a task
            </summary>
        </member>
        <member name="F:Step.Interpreter.CallException.Task">
            <summary>
            The task the program attempted to call
            </summary>
        </member>
        <member name="F:Step.Interpreter.CallException.Arguments">
            <summary>
            The arguments passed to the task
            </summary>
        </member>
        <member name="M:Step.Interpreter.CallException.#ctor(System.Object,System.Object[],System.String)">
            <summary>
            Signal that some problem occurred with the call to a task
            </summary>
            <param name="task">The task that was called</param>
            <param name="arguments">Its arguments</param>
            <param name="message">Message to print</param>
        </member>
        <member name="T:Step.Interpreter.CallFailedException">
            <inheritdoc />
        </member>
        <member name="M:Step.Interpreter.CallFailedException.#ctor(System.Object,System.Object[])">
            <summary>
            Indicates that a call to a Step task that shouldn't be able to fail did fail.
            </summary>
            <param name="task">Task called</param>
            <param name="arguments">Arguments</param>
        </member>
        <member name="T:Step.Interpreter.CoolStep">
            <summary>
            A cooldown timer that can be placed anyplace in a method.
            After succeeding, it will fail for Duration subsequent calls.
            </summary>
        </member>
        <member name="F:Step.Interpreter.CoolStep.ReadyTimes">
            <summary>
            Call number for the task of which this is a part at which this step will become runnable again
            </summary>
        </member>
        <member name="M:Step.Interpreter.CoolStep.ReadyTime(Step.State)">
            <summary>
            Call number (for enclosing task) at which this step will be runnable again
            </summary>
        </member>
        <member name="T:Step.Interpreter.EmitStep">
            <summary>
            A step that dumps a fixed set of tokens to the output.
            EmitSteps always succeed
            </summary>
        </member>
        <member name="F:Step.Interpreter.EmitStep.Text">
            <summary>
            Fixed sequence of tokens to output when this step is performed
            </summary>
        </member>
        <member name="M:Step.Interpreter.EmitStep.Try(Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.Step.Continuation,Step.Interpreter.MethodCallFrame)">
            <summary>
            Output Text and succeed.
            </summary>
            <param name="output">When to write the text</param>
            <param name="e">Variable info.  Not used, but passed on to continuation</param>
            <param name="k">Continuation to run after the end of this method.</param>
            <param name="predecessor">Predecessor frame</param>
            <returns></returns>
        </member>
        <member name="T:Step.Interpreter.HigherOrderBuiltins">
            <summary>
            Implementations of higher-order builtin primitives.
            </summary>
        </member>
        <member name="F:Step.Interpreter.HigherOrderBuiltins.And">
            <summary>
            The built-in And task, for any C# code that needs to recognize references to it.
            </summary>
        </member>
        <member name="F:Step.Interpreter.HigherOrderBuiltins.Or">
            <summary>
            The built-in Or task, for any C# code that needs to recognize references to it.
            </summary>
        </member>
        <member name="F:Step.Interpreter.HigherOrderBuiltins.Not">
            <summary>
            The built-in Not task, for any C# code that needs to recognize references to it.
            </summary>
        </member>
        <member name="M:Step.Interpreter.HigherOrderBuiltins.MaxMinDriver(System.String,System.Object[],System.Int32,Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.Step.Continuation,Step.Interpreter.MethodCallFrame)">
            <summary>
            Core implementation of both Max and Min
            </summary>
        </member>
        <member name="T:Step.Interpreter.HigherOrderBuiltins.CapturedState">
            <summary>
            Used to record the results of a call so those results can be reapplied later.
            Used for all-solutions and maximization meta-predicates
            </summary>
        </member>
        <member name="M:Step.Interpreter.HigherOrderBuiltins.GenerateSolutions(System.String,System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.Step.Continuation,Step.Interpreter.MethodCallFrame)">
            <summary>
            Calls a task with the specified arguments and allows the user to provide their own continuation.
            The only (?) use case for this is when you want to forcibly generate multiple solutions
            </summary>
        </member>
        <member name="M:Step.Interpreter.HigherOrderBuiltins.AllSolutionText(System.String,System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame)">
            <summary>
            Find all solutions to the specified task and arguments.  Return a list of the text outputs of each solution.
            </summary>
        </member>
        <member name="M:Step.Interpreter.HigherOrderBuiltins.GenerateSolutionsFromBody(System.String,System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.Step.Continuation,Step.Interpreter.MethodCallFrame)">
            <summary>
            Calls all the tasks in the body and allows the user to provide their own continuation.
            The only (?) use case for this is when you want to forcibly generate multiple solutions
            </summary>
        </member>
        <member name="M:Step.Interpreter.HigherOrderBuiltins.AllSolutionTextFromBody(System.String,System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame)">
            <summary>
            Find all solutions to the specified sequence of calls.  Return a list of the text outputs of each solution.
            </summary>
        </member>
        <member name="T:Step.Interpreter.Method">
            <summary>
            Internal representation of a method for performing a CompoundTask
            </summary>
        </member>
        <member name="F:Step.Interpreter.Method.Task">
            <summary>
            Task for which this is a method
            </summary>
        </member>
        <member name="F:Step.Interpreter.Method.ArgumentPattern">
            <summary>
            Terms (variables or values) to unify with the arguments in a call to test whether this method is appropriate
            </summary>
        </member>
        <member name="F:Step.Interpreter.Method.FilePath">
            <summary>
            File from which this method was loaded
            </summary>
        </member>
        <member name="F:Step.Interpreter.Method.LineNumber">
            <summary>
            Starting line number of this method in FilePath
            </summary>
        </member>
        <member name="F:Step.Interpreter.Method.LocalVariableNames">
            <summary>
            LocalVariables used in this method
            </summary>
        </member>
        <member name="F:Step.Interpreter.Method.StepChain">
            <summary>
            First Step in the linked list of steps constituting this method
            </summary>
        </member>
        <member name="F:Step.Interpreter.Method.Weight">
            <summary>
            The relative probability of this method being tried first
            </summary>
        </member>
        <member name="M:Step.Interpreter.Method.Try(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <summary>
            Attempt to run this method
            </summary>
            <param name="args">Arguments from the call to the method's task</param>
            <param name="output">Output buffer to write to</param>
            <param name="env">Variable binding information</param>
            <param name="k">Continuation to call if method succeeds</param>
            <param name="pre">Predecessor frame</param>
            <returns>True if the method and its continuation succeeded</returns>
        </member>
        <member name="M:Step.Interpreter.Method.ToString">
            <inheritdoc />
        </member>
        <member name="P:Step.Interpreter.Method.HeadString">
            <summary>
            The argument pattern for this method expressed as the course code for a call
            </summary>
        </member>
        <member name="P:Step.Interpreter.Method.MethodCode">
            <summary>
            An approximate reconstruction of the original course text for this method.
            </summary>
        </member>
        <member name="M:Step.Interpreter.Method.HeadStringWithBindings(Step.Interpreter.BindingEnvironment)">
            <summary>
            Generate the head string, but substitute in the values of any variables
            </summary>
            <param name="env">Binding environment with values of variables</param>
        </member>
        <member name="P:Step.Interpreter.Method.Callees">
            <summary>
            All the tasks called by this method
            </summary>
        </member>
        <member name="P:Step.Interpreter.Method.Calls">
            <summary>
            All the Call steps inside this method
            </summary>
        </member>
        <member name="T:Step.Interpreter.MethodCallFrame">
            <summary>
            Reifies a call to a method
            Used only so that there's a data structure that can be walked to generate a stack backtrace
            NOT THREAD SAFE
            </summary>
        </member>
        <member name="F:Step.Interpreter.MethodCallFrame.MaxStackDepth">
            <summary>
            Maximum number of method calls in a successful execution path.
            </summary>
        </member>
        <member name="P:Step.Interpreter.MethodCallFrame.CurrentFrame">
            <summary>
            The MethodCallFrame for the most recently called frame
            NOT THREAD SAFE
            </summary>
        </member>
        <member name="F:Step.Interpreter.MethodCallFrame.Method">
            <summary>
            The method being called
            </summary>
        </member>
        <member name="P:Step.Interpreter.MethodCallFrame.Task">
            <summary>
            The task being called in this frame.
            </summary>
        </member>
        <member name="P:Step.Interpreter.MethodCallFrame.BindingsAtCallTime">
            <summary>
            The logic variable binding list at the time of the call
            </summary>
        </member>
        <member name="F:Step.Interpreter.MethodCallFrame.Locals">
            <summary>
            The local variables of the environment of the call
            </summary>
        </member>
        <member name="F:Step.Interpreter.MethodCallFrame.Caller">
            <summary>
            Caller's frame - this is the frame of the calling method, not the most recently executed task
            The two are the same for deterministic languages, but can be different for non-deterministic ones
            For example, if A calls B then C and B calls D, then on entry to D, then the method call frame chain
            entry to C is just C -> A.
            
            However, the real C# execution stack looks like:
               C -> D -> B -> A
            Because if C fails, we have to backtrack to D, not to A.  
            </summary>
        </member>
        <member name="F:Step.Interpreter.MethodCallFrame.Predecessor">
            <summary>
            The method that succeeded immediately before this call
            </summary>
        </member>
        <member name="P:Step.Interpreter.MethodCallFrame.CallerChain">
            <summary>
            The chain of this frame and its callers
            </summary>
        </member>
        <member name="P:Step.Interpreter.MethodCallFrame.GoalChain">
            <summary>
            The chain of this frame and its predecessors
            </summary>
        </member>
        <member name="F:Step.Interpreter.MethodCallFrame.StackDepth">
            <summary>
            Number of calls deep this call appears on the stack.
            </summary>
        </member>
        <member name="P:Step.Interpreter.MethodCallFrame.Arglist">
            <summary>
            The effective argument list of the call
            This has to get reconstructed from the ArgumentPattern of the method,
            which is fixed across all calls and contains LocalVariableName objects
            in place of the actual LogicVariables they name (since the latter vary
            from call to call), and the Locals array, which contains the specific
            logicVariables used in this particular call.
            </summary>
        </member>
        <member name="M:Step.Interpreter.MethodCallFrame.GetCallSourceText(Step.Interpreter.BindingList{Step.Interpreter.LogicVariable})">
            <summary>
            Regenerates the textual version of the call in this frame
            </summary>
            <param name="unifications">Binding list currently in effect.  This will generally be whatever the most recent binding list of the interpreter is.</param>
        </member>
        <member name="P:Step.Interpreter.MethodCallFrame.CallExpression">
            <summary>
            Regenerate a tuple representing this call.
            </summary>
        </member>
        <member name="M:Step.Interpreter.MethodCallFrame.ToString">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.UndefinedVariableException">
            <summary>
            Global variable was referenced that was never given a value in the relevant module.
            </summary>
        </member>
        <member name="M:Step.Interpreter.UndefinedVariableException.#ctor(Step.StateVariableName)">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.LocalVariableName">
            <summary>
            The formal variable name for a local variable.
            This is not the run-time local variable itself, which differs from call to call.
            To get the run-time variable for a specific call, use
            BindingEnvironment.Local[LocalVariableName.Index].  This will be a LogicVariable,
            which can be dereferenced through the BindingEnvironment's Unifications field to
            get the actual value of the variable.
            </summary>
        </member>
        <member name="F:Step.Interpreter.LocalVariableName.Name">
            <summary>
            Name of the variable.
            Different methods with variables with the same name have different LocalVariableName objects
            </summary>
        </member>
        <member name="F:Step.Interpreter.LocalVariableName.Index">
            <summary>
            Position in the method's stack frame (the Locals field of the BindingEnvironment) of the LogicVariable
            holding this variable's value.
            </summary>
        </member>
        <member name="M:Step.Interpreter.LocalVariableName.ToString">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.LogicVariable">
            <summary>
            A variable that can be aliased to values and/or other variables using BindingEnvironment.Unify.
            It works like logic variables in any other programming language that has them, although they're
            implemented using deep binding through the Unifications list in the BindingEnvironment, rather than
            shallow binding with a trail (i.e. an undo stack).
            </summary>
        </member>
        <member name="F:Step.Interpreter.LogicVariable.Name">
            <summary>
            Name of the variable.
            This is for debugging purposes only.  It has no functional role.
            </summary>
        </member>
        <member name="M:Step.Interpreter.LogicVariable.#ctor(Step.Interpreter.LocalVariableName)">
            <inheritdoc />
        </member>
        <member name="P:Step.Interpreter.LogicVariable.DebuggerName">
            <summary>
            The name as it should appear in the debugger.
            This name has the UID appended rather than just the raw Name field
            so that different variables with the same Name can be distinguished.
            </summary>
        </member>
        <member name="F:Step.Interpreter.LogicVariable.Uid">
            <summary>
            A unique counter distinguishing this LogicVariable from all others
            </summary>
        </member>
        <member name="M:Step.Interpreter.LogicVariable.ToString">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.TextBuffer">
            <summary>
            Tracks the output buffer and state of the text generated by a task.
            The buffer is writable but the PartialOutput object is read-only.
            Calling Append will write the buffer but return a new PartialOutput
            struct, that is also read-only.
            The read-only-ness is to make backtracking easy.
            </summary>
        </member>
        <member name="F:Step.Interpreter.TextBuffer.Buffer">
            <summary>
            Fixed buffer in which to hold the output
            </summary>
        </member>
        <member name="F:Step.Interpreter.TextBuffer.Length">
            <summary>
            Amount of Buffer currently in use.
            The output generated so far is in cells Buffer[0 ... Length-1]
            </summary>
        </member>
        <member name="F:Step.Interpreter.TextBuffer.WriteMode">
            <summary>
            True means this is a buffer we're writing new text into (write mode/generate mode).
            False means it's a buffer pre-loaded with text we're matching against (read mode/parse mode).
            </summary>
        </member>
        <member name="M:Step.Interpreter.TextBuffer.#ctor(System.Int32)">
            <summary>
            Make an empty PartialOutput with a new buffer.
            </summary>
        </member>
        <member name="M:Step.Interpreter.TextBuffer.MakeReadModeTextBuffer(System.String[])">
            <summary>
            Make buffer with text to be matched by a program running in parse mode
            </summary>
            <param name="text">Text to be parsed</param>
        </member>
        <member name="M:Step.Interpreter.TextBuffer.#ctor(System.String[])">
            <summary>
            Make an empty PartialOutput that stores output in the specified buffer.
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:Step.Interpreter.TextBuffer.NewEmpty">
            <summary>
            Make an empty PartialOutput with a new buffer.
            </summary>
        </member>
        <member name="M:Step.Interpreter.TextBuffer.Append(System.String[])">
            <summary>
            Add tokens to buffer and return a new PartialOutput with the updated length.
            Upon backtracking, the new PartialOutput can be thrown away and this one
            reused.
            </summary>
            <param name="tokens">Tokens to add to output</param>
            <returns>New buffer state</returns>
        </member>
        <member name="M:Step.Interpreter.TextBuffer.Append(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Add tokens to buffer and return a new PartialOutput with the updated length.
            Upon backtracking, the new PartialOutput can be thrown away and this one
            reused.
            </summary>
            <param name="tokens">Tokens to add to output</param>
            <returns>New buffer state</returns>
        </member>
        <member name="M:Step.Interpreter.TextBuffer.Unify(System.String[],Step.Interpreter.TextBuffer@)">
            <summary>
            Write tokens to buffer, if write mode, otherwise attempt to match them
            </summary>
            <param name="tokens">Tokens to match to buffer</param>
            <param name="result">expanded or consumed buffer</param>
            <returns>True on success</returns>
        </member>
        <member name="M:Step.Interpreter.TextBuffer.NextToken(Step.Interpreter.TextBuffer@)">
            <summary>
            Return the next token from a read-mode buffer, or null if at the end.
            </summary>
            <param name="newBuffer">Resulting updated buffer state</param>
            <returns>Next token or null if end of buffer</returns>
            <exception cref="T:System.InvalidOperationException">If buffer is write mode</exception>
        </member>
        <member name="P:Step.Interpreter.TextBuffer.Output">
            <summary>
            Tokens output so far.
            </summary>
        </member>
        <member name="P:Step.Interpreter.TextBuffer.AsString">
            <summary>
            The text generated so far, as a single string.
            </summary>
        </member>
        <member name="P:Step.Interpreter.TextBuffer.ReadCompleted">
            <summary>
            True if all tokens have been read from the buffer
            </summary>
            <exception cref="T:System.InvalidOperationException">If the buffer isn't in read mode</exception>
        </member>
        <member name="M:Step.Interpreter.TextBuffer.ToString">
            <inheritdoc />
        </member>
        <member name="M:Step.Interpreter.TextBuffer.Difference(Step.Interpreter.TextBuffer@,Step.Interpreter.TextBuffer@)">
            <summary>
            Return an array of the strings added to an output buffer between before and after
            </summary>
        </member>
        <member name="M:Step.Interpreter.TextBuffer.Unappend">
            <summary>
            Remove and return the last token in this output
            </summary>
        </member>
        <member name="T:Step.Interpreter.PrimitiveTask">
            <summary>
            Definitions used in making Tasks that are implemented directly as C# code.
            </summary>
        </member>
        <member name="M:Step.Interpreter.PrimitiveTask.#ctor(System.String,System.Nullable{System.Int32})">
            <inheritdoc />
        </member>
        <member name="T:Step.Interpreter.CompoundTask">
            <summary>
            Task implemented as a set of methods, each composed of a series of Steps (sub-tasks)
            Tasks defined by user code are CompoundTasks
            </summary>
        </member>
        <member name="P:Step.Interpreter.CompoundTask.ArgCount">
            <summary>
            Number of arguments expected by the task
            </summary>
        </member>
        <member name="F:Step.Interpreter.CompoundTask.Methods">
            <summary>
            Methods for accomplishing the task
            </summary>
        </member>
        <member name="F:Step.Interpreter.CompoundTask.CallCounts">
            <summary>
            Dictionary of how many successful or pending calls to this task are on this execution path.
            </summary>
        </member>
        <member name="M:Step.Interpreter.CompoundTask.CallCount(Step.State)">
            <summary>
            Return the number of successful or pending calls to this task in the specified state.
            </summary>
        </member>
        <member name="M:Step.Interpreter.CompoundTask.SetFluent(Step.State,System.Object[],System.Boolean)">
            <summary>
            Update the value of a fluent
            </summary>
            <param name="oldState">Current global state</param>
            <param name="arglist">Argument values for this fluent to update</param>
            <param name="truth">New truth value for this fluent on these arguments</param>
            <returns>New global state</returns>
        </member>
        <member name="M:Step.Interpreter.CompoundTask.FluentAssertions(Step.State)">
            <summary>
            All the assertions about this predicate stored in this state using [now ...] 
            </summary>
            <param name="s">State to test</param>
            <returns>argument/truth pairs</returns>
        </member>
        <member name="T:Step.Interpreter.CompoundTask.TaskFlags">
            <summary>
            Declared properties of the task
            </summary>
        </member>
        <member name="F:Step.Interpreter.CompoundTask.TaskFlags.None">
            <summary>
            No properties declared
            </summary>
        </member>
        <member name="F:Step.Interpreter.CompoundTask.TaskFlags.Shuffle">
            <summary>
            Shuffle methods during execution.  Corresponds to the [randomly] declaration.
            </summary>
        </member>
        <member name="F:Step.Interpreter.CompoundTask.TaskFlags.MultipleSolutions">
            <summary>
            Allow this task to retry during backtracking
            </summary>
        </member>
        <member name="F:Step.Interpreter.CompoundTask.TaskFlags.Fallible">
            <summary>
            Don't throw an exception if this task fails
            </summary>
        </member>
        <member name="F:Step.Interpreter.CompoundTask.TaskFlags.Main">
            <summary>
            This task is called form outside the Step code, so don't show a warning if it isn't called.
            </summary>
        </member>
        <member name="F:Step.Interpreter.CompoundTask.TaskFlags.ReadCache">
            <summary>
            Use results stored in the cache
            </summary>
        </member>
        <member name="F:Step.Interpreter.CompoundTask.TaskFlags.WriteCache">
            <summary>
            Add results to the cache
            </summary>
        </member>
        <member name="F:Step.Interpreter.CompoundTask.TaskFlags.Suffix">
            <summary>
            This task is a suffix that modifies the last generated token.
            </summary>
        </member>
        <member name="F:Step.Interpreter.CompoundTask.TaskFlags.ContainsCoolStep">
            <summary>
            True if some method has a cool step
            </summary>
        </member>
        <member name="F:Step.Interpreter.CompoundTask.TaskFlags.Function">
            <summary>
            This fluent is also a function, so for ground instances, its last parameter is unique given its other parameters.
            </summary>
        </member>
        <member name="M:Step.Interpreter.CompoundTask.Declare(Step.Interpreter.CompoundTask.TaskFlags)">
            <summary>
            Programmatic interface for declaring attributes of task
            </summary>
        </member>
        <member name="P:Step.Interpreter.CompoundTask.Shuffle">
            <summary>
            True if the methods of the task should be tried in random order
            </summary>
        </member>
        <member name="P:Step.Interpreter.CompoundTask.Deterministic">
            <summary>
            True if this task should only ever generate at most one output
            </summary>
        </member>
        <member name="P:Step.Interpreter.CompoundTask.MustSucceed">
            <summary>
            True if it's an error for this call not to succeed at least once
            </summary>
        </member>
        <member name="P:Step.Interpreter.CompoundTask.ReadCache">
            <summary>
            If true, this task should check its ResultCache for saved results.
            </summary>
        </member>
        <member name="P:Step.Interpreter.CompoundTask.WriteCache">
            <summary>
            If true, the task should write results back to the cache on successful calls
            in which all arguments are instantiated.
            </summary>
        </member>
        <member name="P:Step.Interpreter.CompoundTask.Suffix">
            <summary>
            This task replaces the previous token in the output
            </summary>
        </member>
        <member name="P:Step.Interpreter.CompoundTask.ContainsCoolStep">
            <summary>
            True if some method contains a cool step
            </summary>
        </member>
        <member name="P:Step.Interpreter.CompoundTask.Function">
            <summary>
            This predicate represents a function.  So the final argument of ground
            instances is unique given the values of the other arguments.
            </summary>
        </member>
        <member name="M:Step.Interpreter.CompoundTask.AddMethod(System.Single,System.Object[],Step.Interpreter.LocalVariableName[],Step.Interpreter.Step,Step.Interpreter.CompoundTask.TaskFlags,System.String,System.Int32)">
            <summary>
            Add a new method for achieving this task
            </summary>
            <param name="weight">The relative probability of this method being tried before the other methods</param>
            <param name="argumentPattern">Terms (variables or values) to unify with the arguments in a call to test whether this method is appropriate</param>
            <param name="localVariableNames">LocalVariables used in this method</param>
            <param name="stepChain">Linked list of Step objects to attempt to execute when running this method</param>
            <param name="path">File from which the method was read</param>
            <param name="lineNumber">Line number where the method starts in the file</param>
            <param name="newFlags">Additional flags to set for the task</param>
        </member>
        <member name="M:Step.Interpreter.CompoundTask.Call(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <summary>
            Call this task with the specified arguments
            </summary>
            <param name="arglist">Task arguments</param>
            <param name="output">Output accumulated so far</param>
            <param name="env">Binding environment</param>
            <param name="predecessor">Most recently succeeded MethodCallFrame</param>
            <param name="k">Continuation</param>
            <returns>True if task succeeded and continuation succeeded</returns>
            <exception cref="T:Step.Interpreter.CallFailedException">If the task fails</exception>
        </member>
        <member name="M:Step.Interpreter.CompoundTask.EraseMethods">
            <summary>
            Remove all defined methods for this task
            </summary>
        </member>
        <member name="P:Step.Interpreter.CompoundTask.Callees">
            <summary>
            All the tasks called by this task
            </summary>
        </member>
        <member name="P:Step.Interpreter.CompoundTask.Calls">
            <summary>
            All the Call steps of all the methods of this task
            </summary>
        </member>
        <member name="M:Step.Interpreter.CompoundTask.FluentUpdates">
            <summary>
            All the fluent updates of the methods of this task.
            </summary>
        </member>
        <member name="T:Step.Interpreter.Step">
            <summary>
            Represents a step in a method
            </summary>
        </member>
        <member name="M:Step.Interpreter.Step.#ctor(Step.Interpreter.Step)">
            <summary>
            Make a new step
            </summary>
        </member>
        <member name="F:Step.Interpreter.Step.Next">
            <summary>
            Next step in the step chain of the method to which this step belongs.
            Null, if this is the last step in the chain.
            </summary>
        </member>
        <member name="T:Step.Interpreter.Step.Continuation">
            <summary>
            A continuation is a procedure to call when a step has completed successfully.
            It takes as arguments the things that might have changed in the process of running the step.
            </summary>
            <returns>True if everything completed successfully, false if we need to backtrack</returns>
        </member>
        <member name="M:Step.Interpreter.Step.Try(Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.Step.Continuation,Step.Interpreter.MethodCallFrame)">
            <summary>
            Attempt to run this step.
            </summary>
            <param name="output">Output accumulated so far</param>
            <param name="e">Variable binding information to use in this step</param>
            <param name="k">Procedure to run if this step and the other steps in its chain are successful</param>
            <param name="predecessor">Predecessor frame</param>
            <returns>True if all steps in the chain, and the continuation are all successful.  False means we're backtracking</returns>
        </member>
        <member name="M:Step.Interpreter.Step.Continue(Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.Step.Continuation,Step.Interpreter.MethodCallFrame)">
            <summary>
            Run any remaining steps in the chain, otherwise run the continuation.
            </summary>
            <returns>True if all steps in the chain, and the continuation are all successful.  False means we're backtracking</returns>
        </member>
        <member name="F:Step.Interpreter.Step.EmptyCalleeList">
            <summary>
            An empty callee list for use in Callees
            </summary>
        </member>
        <member name="P:Step.Interpreter.Step.Callees">
            <summary>
            The callees of just this step, if any
            </summary>
        </member>
        <member name="P:Step.Interpreter.Step.Calls">
            <summary>
            All the Calls contained in this Step.
            </summary>
        </member>
        <member name="P:Step.Interpreter.Step.ChainSteps">
            <summary>
            All the steps in the chain starting with this step
            </summary>
        </member>
        <member name="M:Step.Interpreter.Step.SubSteps">
            <summary>
            The step itself plus any steps from this step's branches, if it's a branching step
            </summary>
            <returns></returns>
        </member>
        <member name="P:Step.Interpreter.Step.CalleesOfChain">
            <summary>
            All the callees of all the calls in this chain
            </summary>
        </member>
        <member name="P:Step.Interpreter.Step.CallsOfChain">
            <summary>
            All the Calls in this chain
            </summary>
        </member>
        <member name="M:Step.Interpreter.Step.ChainFromBody(System.String,System.Object[])">
            <summary>
            Given an array of tuples representing a Step expressions, make a step chain
            </summary>
            <param name="taskName">Name of the task to which this is an argument (for use in error messages)</param>
            <param name="body"></param>
            <returns></returns>
            <exception cref="T:Step.Interpreter.ArgumentTypeException"></exception>
        </member>
        <member name="M:Step.Interpreter.Step.AnyStep(System.Predicate{Step.Interpreter.Step})">
            <summary>
            True if some step in this step chain satisfies the predicate.
            </summary>
        </member>
        <member name="P:Step.Interpreter.Step.Source">
            <summary>
            Make an approximation to the source code for this step;
            </summary>
        </member>
        <member name="T:Step.Output.AOrAnFilter">
            <summary>
            Replaces [a] or [an] with "a" or "an" depending on whether the following token begins with a vowel.
            </summary>
        </member>
        <member name="F:Step.Output.AOrAnFilter.Instance">
            <summary>
            Replaces [a] or [an] with "a" or "an" depending on whether the following token begins with a vowel.
            </summary>
        </member>
        <member name="F:Step.Output.AOrAnFilter.AnOrAToken">
            <summary>
            A token that causes the system to write either "a" or "an" depending on the following token.
            </summary>
        </member>
        <member name="M:Step.Output.AOrAnFilter.Filter(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Replaces [a] or [an] with "a" or "an" depending on whether the following token begins with a vowel.
            </summary>
            <param name="input">Token stream</param>
            <returns>Filtered token stream</returns>
        </member>
        <member name="T:Step.Output.TokenFilter">
            <summary>
            TokenFilters implement transformations done to output text before final untokenization
            They simply transform one token stream to another.
            </summary>
        </member>
        <member name="F:Step.Output.TokenFilter.ControlTokens">
            <summary>
            Control tokens are special string tokens used to indicate commands to token filters.
            Control tokens are strings, but they are compared for pointer equality; there is by definition
            only one copy of a given control token.  This means that unless you're using a version of the
            CLR that interns all strings, then even if you somehow manage to accidentally output a token that
            prints like a control token, it won't be mistaken for a control token.
            </summary>
        </member>
        <member name="M:Step.Output.TokenFilter.MakeControlToken(System.String)">
            <summary>
            Make a new control token.
            </summary>
            <param name="content">Some short, descriptive string indicating what the token is controlling</param>
            <returns>The created token</returns>
        </member>
        <member name="M:Step.Output.TokenFilter.MakeControlTokenAndSubstitution(System.String)">
            <summary>
            Make a new control token that is accessed with the substitution [content]
            </summary>
            <param name="content">Some short, descriptive string indicating what the token is controlling</param>
            <returns>The created token</returns>
        </member>
        <member name="M:Step.Output.TokenFilter.IsControlToken(System.String)">
            <summary>
            True if the token is one of the magic TokenFilter control tokens.
            </summary>
            <param name="token">a token output by a Step program</param>
            <returns>True if it was created by MakeControlToken()</returns>
        </member>
        <member name="M:Step.Output.TokenFilter.Filter(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Transform a sequence of tokens into a filtered (modified) sequence
            </summary>
            <param name="input">token sequence</param>
            <returns>Modified sequence</returns>
        </member>
        <member name="M:Step.Output.TokenFilter.ApplyFilters(Step.Output.TokenFilter[],System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Apply all the TokenFilters to the input, in order.
            So applying {a, b, c } to input returns c.Filter(b.Filter(a.Filter(input)))
            </summary>
            <param name="filters">Array of filters to apply</param>
            <param name="input">Token stream to filter</param>
            <returns>Filtered stream</returns>
        </member>
        <member name="M:Step.Output.TokenFilter.LookAhead(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Transforms a string (a, b, c) into a stream of pairs: ( (a,b), (b,c) , (c, null))
            </summary>
        </member>
        <member name="M:Step.Output.TokenFilter.LookAhead2(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Transforms a string (a, b, c, d) into a stream of triples: ( (a,b,c), (b,c,d) , (c, d, null), (d, null, null))
            </summary>
        </member>
        <member name="T:Step.Output.VerbConjugationFilter">
            <summary>
            Tracks linguistic features of sentence subject and inflects verbs when asked to
            </summary>
        </member>
        <member name="F:Step.Output.VerbConjugationFilter.Instance">
            <summary>
            Tracks linguistic features of sentence subject and inflects verbs when asked to
            </summary>
        </member>
        <member name="M:Step.Output.VerbConjugationFilter.Filter(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Tracks linguistic features of sentence subject and inflects verbs when asked to
            </summary>
        </member>
        <member name="T:Step.Output.Inflection">
            <summary>
            Implements a best effort to convert between English plural and singular noun inflections
            </summary>
        </member>
        <member name="T:Step.Output.Inflection.Number">
            <summary>
            The linguistic feature indicating plurality
            </summary>
        </member>
        <member name="F:Step.Output.Inflection.Number.Singular">
            <summary>
            One thing
            </summary>
        </member>
        <member name="F:Step.Output.Inflection.Number.Plural">
            <summary>
            More than one things
            </summary>
        </member>
        <member name="T:Step.Output.Inflection.Person">
            <summary>
            The linguistic feature indicating the relationship between a noun and the speaker or addressee
            </summary>
        </member>
        <member name="F:Step.Output.Inflection.Person.First">
            <summary>
            The noun is the speaker
            </summary>
        </member>
        <member name="F:Step.Output.Inflection.Person.Second">
            <summary>
            The noun is the addressee
            </summary>
        </member>
        <member name="F:Step.Output.Inflection.Person.Third">
            <summary>
            The noun is not the speaker or addressee
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.ThirdPersonSingularFormOfEnglishVerb(System.String,System.String)">
            <summary>
            Given the non-TPS present tense form of an English verb, return the TPS version
            </summary>
            <param name="verb">base present tense of verb</param>
            <param name="suffix">expected suffix ("s" or "es")</param>
            <returns>Third-person singular form</returns>
        </member>
        <member name="M:Step.Output.Inflection.DeclareIrregularNoun(System.String,System.String)">
            <summary>
            Add the conjugations of a new irregular noun.
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.IsPreposition(System.String)">
            <summary>
            True if the word can be used as a preposition
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.PluralOfNoun(System.String[])">
            <summary>
            The plural form of a singular noun
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.PluralOfNoun(System.String)">
            <summary>
            The plural form of a one-word singular noun
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.SingularOfNoun(System.String)">
            <summary>
            The singular form of a one-word plural noun
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.SingularOfNoun(System.String[])">
            <summary>
            The singular form of a plural noun
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.NounAppearsPlural(System.String)">
            <summary>
            Heuristically guess is this one-word noun is in plural form
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.NounAppearsPlural(System.String[])">
            <summary>
            Heuristically guess is this noun is in plural form
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.SingularOfVerb(System.String[])">
            <summary>
            The singular form of a plural form verb
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.PluralOfVerb(System.String[])">
            <summary>
            The plural form of a singular form verb
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.IsGerund(System.String[])">
            <summary>
            Heuristically guess if this verb is in gerund form
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.GerundsOfVerb(System.String[])">
            <summary>
            Enumerate every potential gerund form of a (third person) plural verb
            It's hard to know algorithmically which is correct, so we just allow
            all of them.
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.RegularGerundsOfWord(System.String)">
            <summary>
            Enumerate every possible gerund form of a single-word verb.
            It's hard to know algorithmically which one is correct, so we allow
            all of them.
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.BaseFormOfGerund(System.String[])">
            <summary>
            Convert the gerund form of a verb to its base form
            </summary>
        </member>
        <member name="M:Step.Output.Inflection.ReplaceCopula(System.String[],System.String)">
            <summary>
            Replace any occurrence of the copula (e.g. is/are/be/being) with the specified replacement
            </summary>
        </member>
        <member name="T:Step.Output.TextUtilities">
            <summary>
            Random utilities for working with text
            </summary>
        </member>
        <member name="F:Step.Output.TextUtilities.NewLineToken">
            <summary>
            Internal token used to signify the start of a new line
            </summary>
        </member>
        <member name="F:Step.Output.TextUtilities.NewParagraphToken">
            <summary>
            Internal token used to signify the start of a new paragraph
            </summary>
        </member>
        <member name="F:Step.Output.TextUtilities.FreshLineToken">
            <summary>
            Internal token used to signify that any future tokens should start on a fresh line.
            </summary>
        </member>
        <member name="F:Step.Output.TextUtilities.ForceSpaceToken">
            <summary>
            A token that forces a space between two tokens that wouldn't otherwise have have spaces between them.
            </summary>
        </member>
        <member name="M:Step.Output.TextUtilities.Untokenize(System.Collections.Generic.IEnumerable{System.String},Step.FormattingOptions)">
            <summary>
            Convert a sequence of tokens into a single text string, adding spaces where appropriate.
            </summary>
        </member>
        <member name="M:Step.Output.TextUtilities.Capitalize(System.String)">
            <summary>
            Force first character of token to be capitalized.
            </summary>
        </member>
        <member name="M:Step.Output.TextUtilities.PunctuationToken(System.String)">
            <summary>
            True when string consists of just a single punctuation mark.
            </summary>
        </member>
        <member name="M:Step.Output.TextUtilities.StartsWithVowel(System.String)">
            <summary>
            True if the first character of the string is a vowel.
            </summary>
        </member>
        <member name="T:Step.Output.Writer">
            <summary>
            Formatted writing of Step terms (i.e. tuples, variables, and atomic values)
            </summary>
        </member>
        <member name="M:Step.Output.Writer.TermToString(System.Object,Step.Interpreter.BindingList{Step.Interpreter.LogicVariable})">
            <summary>
            Convert a Step term to a string as it would appear in the source code.
            </summary>
        </member>
        <member name="T:Step.Parser.CsvFileTokenStream">
            <summary>
            Transforms a CSV file into a sequence of tokens (strings not containing whitespace) defining methods for a predicate.
            </summary>
        </member>
        <member name="M:Step.Parser.CsvFileTokenStream.#ctor(System.IO.TextReader,System.String)">
            <summary>
            Make a new token stream reading from the specified text stream
            </summary>
            <param name="input">Stream to read from</param>
            <param name="filePath">Path of the stream if it comes from a file (for debug messages)</param>
        </member>
        <member name="F:Step.Parser.CsvFileTokenStream.EscapeStrings">
            <summary>
            If true, treat capitalized tokens in cells as strings rather than global variables
            </summary>
        </member>
        <member name="M:Step.Parser.CsvFileTokenStream.GetRow">
            <summary>
            Read a row from the spreadsheet.
            </summary>
            <returns>Array of column strings</returns>
        </member>
        <member name="M:Step.Parser.CsvFileTokenStream.ReadQuoted">
            <summary>
            Read a quoted column
            This just reads into the string buffer.  We depend on the caller to move the string buffer into the row buffer.
            </summary>
        </member>
        <member name="F:Step.Parser.TokenStream.FilePath">
            <summary>
            Path to file being read from, if any
            </summary>
        </member>
        <member name="F:Step.Parser.TokenStream.LeftDoubleQuote">
            <summary>
            The Unicode left double quote
            </summary>
        </member>
        <member name="F:Step.Parser.TokenStream.RightDoubleQuote">
            <summary>
            The Unicode right double quote
            </summary>
        </member>
        <member name="P:Step.Parser.TokenStream.LineNumber">
            <summary>
            Line number of file being read from
            </summary>
        </member>
        <member name="P:Step.Parser.TokenStream.Tokens">
            <summary>
            The stream of tokens read from the stream.
            </summary>
        </member>
        <member name="P:Step.Parser.TokenStream.End">
            <summary>
            True if we're at the end of the stream
            </summary>
        </member>
        <member name="P:Step.Parser.TokenStream.Peek">
            <summary>
            Return the current character, without advancing
            </summary>
        </member>
        <member name="T:Step.Parser.DefinitionStream">
            <summary>
            Reads a stream of method definitions from a TextReader.
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.DefineSubstitution(System.String,System.Object)">
            <summary>
            Defines that any occurrence of the single-element bracketed expression [macro] in the input text should be replaced by substitution.
            </summary>
            <param name="macro"></param>
            <param name="substitution"></param>
        </member>
        <member name="M:Step.Parser.DefinitionStream.#ctor(System.IO.TextReader,Step.Module,System.String)">
            <summary>
            Reads definitions from the specified stream
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.#ctor(Step.Parser.ExpressionStream,Step.Module)">
            
             Make a new definition stream
             
        </member>
        <member name="F:Step.Parser.DefinitionStream.Module">
            <summary>
            Module into which this is reading definitions
            </summary>
        </member>
        <member name="F:Step.Parser.DefinitionStream.expressions">
            <summary>
            Expressions being read from the stream
            </summary>
        </member>
        <member name="F:Step.Parser.DefinitionStream.end">
            <summary>
            True if we've hit the end of the stream
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.MoveNext">
            <summary>
            Get the next expression from expressions, updating end.
            </summary>
        </member>
        <member name="P:Step.Parser.DefinitionStream.Peek">
            <summary>
            Current expression
            </summary>
        </member>
        <member name="P:Step.Parser.DefinitionStream.PeekAndSubstitute">
            <summary>
            Peek, but apply substitution
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.Get">
            <summary>
            Return the current expression and move to the next
            </summary>
            <returns></returns>
        </member>
        <member name="M:Step.Parser.DefinitionStream.SwallowNewlines">
            <summary>
            Skip forward to the next token that isn't a newline
            </summary>
        </member>
        <member name="F:Step.Parser.DefinitionStream.multiLine">
            <summary>
            The current definition is a single line definition
            </summary>
        </member>
        <member name="F:Step.Parser.DefinitionStream.EndOfLine">
            <summary>
            The actual token representation of an end of line
            </summary>
        </member>
        <member name="P:Step.Parser.DefinitionStream.EndOfDefinition">
            <summary>
            True if we're at the end of the current definition
            </summary>
        </member>
        <member name="P:Step.Parser.DefinitionStream.EndOfLineToken">
            <summary>
            True if we're at an end of line token
            </summary>
        </member>
        <member name="P:Step.Parser.DefinitionStream.ExplicitEndToken">
            <summary>
            True if we're at an "[end]" expression
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.IsLocalVariableName(System.Object)">
            <summary>
            True if the string is a valid local variable name
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.IsNonAnonymousLocalVariableName(System.Object)">
            <summary>
            The token is a valid name of a non-anonymous local variable
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.IsSingletonVariableName(System.String)">
            <summary>
            The local variable name indicates the programmer intended it to be a singleton.
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.IsIntendedAsSingleton(Step.Interpreter.LocalVariableName)">
            <summary>
            The local variable name indicates the programmer intended it to be a singleton.
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.IsGlobalVariableName(System.Object)">
            <summary>
            True if the string is a valid global variable name
            </summary>
        </member>
        <member name="F:Step.Parser.DefinitionStream.locals">
            <summary>
            Local variables of the definition currently being parsed.
            </summary>
        </member>
        <member name="F:Step.Parser.DefinitionStream.tokensToEmit">
            <summary>
            Tokens being accumulated for the current Emit step of the current method.
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.GetLocal(System.String)">
            <summary>
            Return the local variable for the current method with the specified name,
            creating one and adding it to locals, if there isn't one.
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.CanonicalizeArglist(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Identify tokens that identify non-strings (variables, numbers) and replace them
            with their internal representations
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.Canonicalize(System.Object)">
            <summary>
            Return the internal representation for the term denoted by the specified token
            </summary>
        </member>
        <member name="P:Step.Parser.DefinitionStream.Definitions">
            <summary>
            Read, parse, and return the information for all method definitions in the stream
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.ReadDefinition">
            <summary>
            Read and parse the next method definition
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.ReadHead">
            <summary>
            Read the task name and argument pattern
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.TryProcessMethodCall(Step.Interpreter.Step.ChainBuilder)">
            <summary>
            If we're looking at a method call, compile it.
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.ReadAlternativeBranches(System.String)">
            <summary>
            Read the text of a branch of a [randomly] or [firstOf] expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:Step.Parser.DefinitionStream.ReadCase(System.Object)">
            <summary>
            Read a new CompoundTask that takes one argument, that corresponds to the body of an inline case expression.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Step.Parser.DefinitionStream.TryProcessMentionExpression(Step.Interpreter.Step.ChainBuilder)">
            <summary>
            If we're looking at a mention expression (?x, ?x/Foo, ?x/Foo/Bar, etc.), compile it.
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.ReadComplexMentionExpression(Step.Interpreter.Step.ChainBuilder,Step.Interpreter.IVariableName)">
            <summary>
            Read an expression of the form ?local/STUFF
            Called after ?local has already been read.
            </summary>
            <param name="chain">Chain to add to</param>
            <param name="variable">The variable before the /</param>
        </member>
        <member name="M:Step.Parser.DefinitionStream.ReadMentionExpressionTail(Step.Interpreter.Step.ChainBuilder,Step.Interpreter.IVariableName,System.Object)">
            <summary>
            Called after the last "/" of a complex mention expression.
            </summary>
            <param name="chain">Chain to add to</param>
            <param name="variable">Result of the expression from before the last "/"</param>
            <param name="targetVar">Task to call on local</param>
        </member>
        <member name="M:Step.Parser.DefinitionStream.TryProcessTextBlock(Step.Interpreter.Step.ChainBuilder)">
            <summary>
            If this is a sequence of fixed text tokens, compile them into an EmitStep.
            </summary>
        </member>
        <member name="M:Step.Parser.DefinitionStream.CheckForWarnings">
            <summary>
            Issue warnings for any singleton variables
            </summary>
        </member>
        <member name="T:Step.Parser.ExpressionStream">
            <summary>
            Transforms a sequence of tokens into a sequence of expressions
            An expression is either a token, or an array of tokens generated by a bracketed expression.
            </summary>
        </member>
        <member name="M:Step.Parser.ExpressionStream.#ctor(System.IO.TextReader,System.String)">
            <summary>
            Make an object that reads a stream of nested expressions from a file
            </summary>
        </member>
        <member name="M:Step.Parser.ExpressionStream.#ctor(System.String)">
            <summary>
            Make an object that reads a stream of nested expressions from a file
            </summary>
        </member>
        <member name="M:Step.Parser.ExpressionStream.#ctor(Step.Parser.TokenStream)">
            <summary>
            Make an object that reads a stream of nested expressions from a TokenStream
            </summary>
        </member>
        <member name="P:Step.Parser.ExpressionStream.FilePath">
            <summary>
            File from which this data is being read, if any
            </summary>
        </member>
        <member name="P:Step.Parser.ExpressionStream.LineNumber">
            <summary>
            Line number in file from which we are currently reading.
            </summary>
        </member>
        <member name="F:Step.Parser.ExpressionStream.tokens">
            <summary>
            Sequence of tokens read from the original stream
            </summary>
        </member>
        <member name="F:Step.Parser.ExpressionStream.end">
            <summary>
            True if we've hit the end of the stream
            </summary>
        </member>
        <member name="M:Step.Parser.ExpressionStream.MoveNext">
            <summary>
            Move to the next token in the stream
            </summary>
        </member>
        <member name="M:Step.Parser.ExpressionStream.Get">
            <summary>
            Return the current token and move to the next
            </summary>
        </member>
        <member name="P:Step.Parser.ExpressionStream.Peek">
            <summary>
            Returns the current token without advancing to the next token.
            </summary>
        </member>
        <member name="P:Step.Parser.ExpressionStream.Expressions">
            <summary>
            Sequence of tokens, with bracketed groups of expressions replace with a single array.
            </summary>
        </member>
        <member name="T:Step.Parser.SyntaxError">
            <summary>
            Represents a syntactic error in a .step file
            </summary>
        </member>
        <member name="M:Step.Parser.SyntaxError.#ctor(System.String,System.String,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Step.Parser.TextFileTokenStream">
            <summary>
            Transforms a stream of characters into a sequence of tokens (strings not containing whitespace)
            </summary>
        </member>
        <member name="M:Step.Parser.TextFileTokenStream.#ctor(System.IO.TextReader,System.String)">
            <summary>
            Make a new token stream reading from the specified text stream
            </summary>
            <param name="input">Stream to read from</param>
            <param name="filePath">Path of the stream if it comes from a file (for debug messages)</param>
        </member>
        <member name="F:Step.Parser.TextFileTokenStream.token">
            <summary>
            Buffer for accumulating characters into tokens
            </summary>
        </member>
        <member name="P:Step.Parser.TextFileTokenStream.HaveToken">
            <summary>
            True it token buffer non-empty
            </summary>
        </member>
        <member name="M:Step.Parser.TextFileTokenStream.AddCharToToken(System.Boolean)">
            <summary>
            Add current stream character to token
            </summary>
        </member>
        <member name="M:Step.Parser.TextFileTokenStream.ConsumeToken(System.Boolean)">
            <summary>
            Return the accumulated characters as a token and clear the token buffer.
            </summary>
        </member>
        <member name="M:Step.Parser.TextFileTokenStream.Get(System.Boolean)">
            <summary>
            Return the current character and advance to the next
            </summary>
            <returns></returns>
        </member>
        <member name="M:Step.Parser.TextFileTokenStream.Skip">
            <summary>
            Synonym for Get().  Used to indicate the character is being deliberately thrown away.
            </summary>
        </member>
        <member name="M:Step.Parser.TextFileTokenStream.SkipWhitespace">
            <summary>
            Skip over all whitespace chars, except newlines (they're considered tokens)
            </summary>
        </member>
        <member name="P:Step.Parser.TextFileTokenStream.IsWhiteSpace">
            <summary>
            Current character is non-newline whitespace
            </summary>
        </member>
        <member name="P:Step.Parser.TextFileTokenStream.IsPunctuationNotSpecial">
            <summary>
            Current character is some punctuation symbol other than '?'
            '?' is treated specially because it's allowed to start a variable-name token.
            </summary>
        </member>
        <member name="P:Step.Parser.TextFileTokenStream.IsEndOfWord">
            <summary>
            True if the current character can't be a continuation of a word token.
            </summary>
        </member>
        <member name="P:Step.Parser.TextFileTokenStream.Tokens">
            <summary>
            The stream of tokens read from the stream.
            </summary>
        </member>
        <member name="T:Step.State">
            <summary>
            Contains the current dynamic state: the result of any set expressions that have been executed,
            or any other state changes that might need to be undone upon backtracking
            </summary>
        </member>
        <member name="F:Step.State.Bindings">
            <summary>
            Binding list for global variables
            </summary>
        </member>
        <member name="M:Step.State.Bind(Step.Interpreter.StateElement,System.Object)">
            <summary>
            Binds the specified state element to the specified value
            </summary>
            <returns>New dynamic state</returns>
        </member>
        <member name="P:Step.State.Item(Step.Interpreter.StateElement)">
            <summary>
            The value of the specified dynamic state element
            </summary>
        </member>
        <member name="M:Step.State.Lookup(Step.Interpreter.StateElement)">
            <summary>
            The value of the specified dynamic state element
            </summary>
        </member>
        <member name="M:Step.State.LookupOrDefault(Step.Interpreter.StateElement,System.Object)">
            <summary>
            The value of the specified dynamic state element or the specified default value, if the state element
            has no value.
            </summary>
        </member>
        <member name="M:Step.State.TryGetValue(Step.Interpreter.StateElement,System.Object@)">
            <summary>
            Set result to the value of e and return true, if e is bound, else return false
            </summary>
        </member>
        <member name="F:Step.State.Empty">
            <summary>
            A State containing no bindings
            </summary>
        </member>
        <member name="P:Step.State.Contents">
            <summary>
            Returns contents as a flat array, sorted.
            Not performant - just use for examining the contents in the debugger.
            </summary>
        </member>
        <member name="T:Step.DictionaryStateElement`2">
            <summary>
            A dictionary whose contents is stored in the global State object
            </summary>
        </member>
        <member name="M:Step.DictionaryStateElement`2.#ctor(System.String,System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Make a new dictionary that lives in the global state.
            Since it lives in the global state, different states will have
            different sets of bindings, and making a new binding will
            create a new global state.
            </summary>
            <param name="name">Name to give to the dictionary</param>
            <param name="keyComparer">Equality comparer for to use for keys</param>
            <param name="valueComparer">Equality comparer to use for values</param>
        </member>
        <member name="M:Step.DictionaryStateElement`2.Dictionary(Step.State)">
            <summary>
            The version of the dictionary stored in the specified state
            </summary>
        </member>
        <member name="M:Step.DictionaryStateElement`2.ContainsKey(Step.State,`0)">
            <summary>
            Test if the specified Global state contains a binding within this dictionary for the specified key
            </summary>
        </member>
        <member name="M:Step.DictionaryStateElement`2.TryGetValue(Step.State,`0,`1@)">
            <summary>
            Attempt to find the result associated with this key in the specified state object
            </summary>
            <param name="state">Global state object to search in</param>
            <param name="key">Key to search for</param>
            <param name="result">Value associated with key, if any</param>
            <returns>True if there is a value associated with the key</returns>
        </member>
        <member name="M:Step.DictionaryStateElement`2.GetValueOrDefault(Step.State,`0,`1)">
            <summary>
            Get the value of the specified key in this dictionary for the specified state, if present.
            Otherwise, return the specified default value.
            </summary>
        </member>
        <member name="M:Step.DictionaryStateElement`2.SetItem(Step.State,`0,`1)">
            <summary>
            Associates a new value to the specified key in this dictionary, in the specified State.
            </summary>
            <param name="oldState">State before the modification</param>
            <param name="key">Key to add</param>
            <param name="value">Value to associate with key</param>
            <returns>New global state</returns>
        </member>
        <member name="M:Step.DictionaryStateElement`2.Bindings(Step.State)">
            <summary>
            Get all the key/value bindings currently in effect for this dictionary in the specified state.
            </summary>
        </member>
        <member name="T:Step.Term">
            <summary>
            Methods related to testing data-values in logic-specific ways
            Term is the word used in logic for something that can be an argument to a predicate.
            </summary>
        </member>
        <member name="M:Step.Term.IsGround(System.Object[])">
            <summary>
            True if the tuple contains no variables.
            This assumes that the value has already been resolved relative to an environment
            so any logic variables are uninstantiated.
            </summary>
        </member>
        <member name="M:Step.Term.IsGround(System.Object)">
            <summary>
            True if object is *not* a logic variable or array containing a logic variable.
            This assumes that the value has already been resolved relative to an environment
            so any logic variables are uninstantiated.
            </summary>
        </member>
        <member name="M:Step.Term.LiterallyEqual(System.Object,System.Object)">
            <summary>
            Test if two terms are literally equal.  So [?x] and [?x] are literally equal, but [?x] and [?y] are not, even if they are unifiable.
            </summary>
        </member>
        <member name="T:Step.Term.Comparer">
            <summary>
            IEqualityComparer for terms in the step language.
            This does recursive comparison and hashing for object[] values, and the default
            comparison and hash implementations for others.
            </summary>
        </member>
        <member name="F:Step.Term.Comparer.Default">
            <summary>
            Singleton instance of the comparer 
            </summary>
        </member>
        <member name="F:Step.Term.Comparer.ForFunctions">
            <summary>
            Comparer to use for cache results on function fluents; ignores the last argument.
            </summary>
        </member>
        <member name="F:Step.Term.Comparer.FunctionComparer">
            <summary>
            True if this is the comparer used for result caches on functions
            If so, we need to ignore the last element of a top-level tuple.
            </summary>
        </member>
        <member name="T:Step.Utilities.Documentation">
            <summary>
            Utilities for generating documentation about tasks
            </summary>
        </member>
        <member name="M:Step.Utilities.Documentation.DefineGlobals(Step.Module)">
            <summary>
            Add bindings for documentation functions
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:Step.Utilities.Documentation.Apropos(System.Object[],Step.Interpreter.TextBuffer,Step.Interpreter.BindingEnvironment,Step.Interpreter.MethodCallFrame,Step.Interpreter.Step.Continuation)">
            <summary>
            Find all tasks that contain the specified string in their name, arglists, or documentation, and print their documentation.
            </summary>
        </member>
        <member name="M:Step.Utilities.Documentation.WriteHtmlReference(Step.Module,System.String)">
            <summary>
            Write a little manual in HTML format
            </summary>
            <param name="m">Module to get definitions from</param>
            <param name="path">Path to write the file to</param>
        </member>
        <member name="M:Step.Utilities.Documentation.SectionIntroduction(System.String,System.String)">
            <summary>
            Specify text to print in the manual between the heading for a section and the first task description.
            </summary>
        </member>
        <member name="T:Step.Utilities.Documentation.DocumentationFormatter">
            <summary>
            Formats documentation for a given output language (txt, unity rich text, or html)
            </summary>
        </member>
        <member name="M:Step.Utilities.Documentation.DocumentationFormatter.#ctor(System.Func{System.String,System.String},System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Define the format of a particular output format for printing documentation.
            All arguments are optional.
            </summary>
            <param name="escapeText">Function for escaping special characters in a string</param>
            <param name="startArgument">Prefix to print before an argument name</param>
            <param name="endArgument">Suffix to print after an argument name</param>
            <param name="startCode">Prefix to print before code</param>
            <param name="endCode">Suffix to print after code</param>
            <param name="startTaskName">Prefix to print before a task name</param>
            <param name="endTaskName">Suffix to print after a task name</param>
            <param name="lineBreak">Code to use to force a line break</param>
        </member>
        <member name="M:Step.Utilities.Documentation.DocumentationFormatter.FormatString(System.String)">
            <summary>
            Format a string for this output format
            </summary>
        </member>
        <member name="M:Step.Utilities.Documentation.DocumentationFormatter.FormatArgument(System.String)">
            <summary>
            Format an argument name for this output format
            </summary>
        </member>
        <member name="M:Step.Utilities.Documentation.DocumentationFormatter.FormatTaskName(System.String)">
            <summary>
            Format a task name for this output format
            </summary>
        </member>
        <member name="M:Step.Utilities.Documentation.DocumentationFormatter.FormatCall(System.String,System.String[])">
            <summary>
            Format a call signature for this output format
            </summary>
        </member>
        <member name="M:Step.Utilities.Documentation.DocumentationFormatter.FormatDocumentation(Step.Interpreter.Task)">
            <summary>
            Generate the documentation for a task in this output format
            </summary>
            <param name="t">Task to document</param>
            <returns>Documentation</returns>
        </member>
        <member name="F:Step.Utilities.Documentation.RawTextFormatter">
            <summary>
            Formats documentation as raw text with now markup.
            </summary>
        </member>
        <member name="F:Step.Utilities.Documentation.UnityRichTextFormatter">
            <summary>
            Formats documentation with markup for the Unity's rich text text boxes
            </summary>
        </member>
        <member name="F:Step.Utilities.Documentation.HtmlFormatter">
            <summary>
            Formats documentation with HTML markup
            </summary>
        </member>
        <member name="T:Step.Utilities.Randomization">
            <summary>
            Utilities for generating random numbers and permutations.
            </summary>
        </member>
        <member name="F:Step.Utilities.Randomization.Random">
            <summary>
            Random number generator used by the Step interpreter.
            Setting its seed will fix the behavior of the system.
            </summary>
        </member>
        <member name="M:Step.Utilities.Randomization.IntegerInclusive(System.Int32,System.Int32)">
            <summary>
            Generate a random integer in the range [low, high]
            </summary>
            <param name="low">Smallest number to allow</param>
            <param name="high">Largest number to allow</param>
            <returns></returns>
        </member>
        <member name="M:Step.Utilities.Randomization.IntegerExclusive(System.Int32,System.Int32)">
            <summary>
            Generate a random integer in the range [low, high), that is, low can be generated but not high.
            </summary>
            <param name="low">Smallest allowed number</param>
            <param name="high">Largest allowed number plus one</param>
            <returns>Generated number</returns>
        </member>
        <member name="M:Step.Utilities.Randomization.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
            Make a randomly permuted copy of sequence
            </summary>
        </member>
        <member name="M:Step.Utilities.Randomization.WeightedShuffle``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Single})">
            <summary>
            Return a shuffled version of the elements in sequence, given the specified weights.
            This is based on Weighted Random Sampling (2005; Efraimidis, Spirakis), Encyclopedia of Algorithms.
            http://utopia.duth.gr/~pefraimi/research/data/2007EncOfAlg.pdf
            </summary>
        </member>
        <member name="M:Step.Utilities.Randomization.BadShuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
            Enumerates the elements of list in a random order.
            This is good enough to seem random to a human, but actually only generates O(n^2/log n)
            possible permutations, which is much less than the n! actual permutations.
            The reason for this limitation is that it lets us enumerate using constant space.
            </summary>
            <param name="list">List to enumerate</param>
            <typeparam name="T">Type of the list element</typeparam>
            <returns>Random permutation of list</returns>
        </member>
        <member name="M:Step.Utilities.Randomization.BadShuffle(System.Collections.IList)">
            <summary>
            Enumerates the elements of list in a random order.
            This is good enough to seem random to a human, but actually only generates O(n^2/log n)
            possible permutations, which is much less than the n! actual permutations.
            The reason for this limitation is that it lets us enumerate using constant space.
            </summary>
            <param name="list">List to enumerate</param>
            <returns>Random permutation of list</returns>
        </member>
        <member name="M:Step.Utilities.Randomization.MaybeShuffle``1(System.Collections.Generic.IList{``0},System.Boolean)">
            <summary>
            Returns either the original list, if shouldShuffle=false,
            or a random permutation generated with BadShuffle(), if shouldShuffle=true.
            </summary>
            <param name="list">List to enumerate</param>
            <param name="shouldShuffle">Whether to randomize the order</param>
            <typeparam name="T">Element type</typeparam>
            <returns>Enumeration of the elements</returns>
        </member>
        <member name="T:Step.Module">
            <summary>
            Stores values of global state variables
            </summary>
        </member>
        <member name="F:Step.Module.RichTextStackTraces">
            <summary>
            Stack traces should be generated with Unity rich text markup
            </summary>
        </member>
        <member name="F:Step.Module.dictionary">
            <summary>
            Table of values assigned by this module to different global variables
            </summary>
        </member>
        <member name="F:Step.Module.Parent">
            <summary>
            Parent module to try if a variable can't be found in this module;
            </summary>
        </member>
        <member name="T:Step.Module.BindHook">
            <summary>
            A user-defined procedure that can be called to import the value of a variable
            </summary>
            <param name="name">Variable to look up</param>
            <param name="value">Value found, if any</param>
            <returns>True if variable found</returns>
        </member>
        <member name="F:Step.Module.bindHooks">
            <summary>
            Optional list of hooks to try when a variable can't be found.
            </summary>
        </member>
        <member name="F:Step.Module.Global">
            <summary>
            The global Module that all other modules inherit from by default.
            </summary>
        </member>
        <member name="F:Step.Module.Name">
            <summary>
            Name of the module for debugging purposes
            </summary>
        </member>
        <member name="F:Step.Module.FormattingOptions">
            <summary>
            Formatting options to use in Call.
            </summary>
        </member>
        <member name="F:Step.Module.SourceExtension">
            <summary>
            Extension used for source files
            </summary>
        </member>
        <member name="F:Step.Module.CsvExtension">
            <summary>
            Extension for CSV files
            </summary>
        </member>
        <member name="M:Step.Module.#ctor(System.String)">
            <summary>
            Make a module that inherits from Global
            </summary>
        </member>
        <member name="M:Step.Module.#ctor(System.String,Step.Module,System.String[])">
            <summary>
            Make a module with the Global module as parent and load the specified source files into it.
            </summary>
            <param name="name">Name of the Module, for debugging purposes</param>
            <param name="parent">Parent module for this module.  This will usually be Module.Global</param>
            <param name="sourceFiles">Definition files to load</param>
        </member>
        <member name="M:Step.Module.#ctor(System.String,Step.Module)">
            <summary>
            Make a module that inherits from the specified parent
            </summary>
        </member>
        <member name="P:Step.Module.Item(System.String)">
            <summary>
            Returns the value of the variable with the specified name
            </summary>
            <param name="variableName">Name (string) of the variable</param>
            <returns>Value</returns>
            <exception cref="T:Step.Interpreter.UndefinedVariableException">If getting a variable and it is not listed in this module or its ancestors</exception>
        </member>
        <member name="P:Step.Module.Item(Step.StateVariableName)">
            <summary>
            Returns the value of the global variable with the specified name
            </summary>
            <param name="v">The variable</param>
            <returns>Value</returns>
            <exception cref="T:Step.Interpreter.UndefinedVariableException">If getting a variable and it is not listed in this module or its ancestors</exception>
        </member>
        <member name="M:Step.Module.Defines(System.String)">
            <summary>
            True if this module has its own definition of the specified variable
            </summary>
        </member>
        <member name="M:Step.Module.Defines(Step.StateVariableName)">
            <summary>
            True if this module has its own definition of the specified variable
            </summary>
        </member>
        <member name="P:Step.Module.Bindings">
            <summary>
            All the variable bindings in this module.
            </summary>
        </member>
        <member name="P:Step.Module.AllBindings">
            <summary>
            All the variable bindings in this module and its parent.
            </summary>
        </member>
        <member name="P:Step.Module.DefinedTasks">
            <summary>
            All CompoundTasks defined in this Module
            </summary>
        </member>
        <member name="M:Step.Module.FindTask(Step.StateVariableName,System.Int32,System.Boolean,System.String,System.Int32)">
            <summary>
            Find the CompoundTask named by the specified variable, creating one if necessary.
            </summary>
            <param name="v">Task variable</param>
            <param name="argCount">Number of arguments the task is expected to have</param>
            <param name="createIfNeeded">If true and variable is unbound, create a new task to bind it to.</param>
            <param name="path">Source file of method referencing this task, if relevant</param>
            <param name="lineNumber">Source file line number of method referencing this task, if relevant</param>
            <returns>The task</returns>
            <exception cref="T:System.ArgumentException">If variable is defined but isn't a CompoundTask</exception>
        </member>
        <member name="M:Step.Module.Eval(Step.State,System.Object[])">
            <summary>
            Run the call in the specified tuple.
            </summary>
            <param name="state">State in which to run the code</param>
            <param name="call">Tuple representing the task to call and its arguments</param>
            <exception cref="T:System.ArgumentException">If first element of call is not a task</exception>
        </member>
        <member name="M:Step.Module.Call(Step.State,System.String,System.Object[])">
            <summary>
            Calls the named task with the specified arguments and returns the text it generates
            </summary>
            <param name="state">Global variable bindings to use in the call, if any.</param>
            <param name="taskName">Name of the task</param>
            <param name="args">Arguments to task, if any</param>
            <returns>Generated text as one big string, and final values of global variables.  Or null if the task failed.</returns>
        </member>
        <member name="M:Step.Module.Call(Step.State,Step.Interpreter.Task,System.Object[])">
            <summary>
            Calls the named task with the specified arguments and returns the text it generates
            </summary>
            <param name="state">Global variable bindings to use in the call, if any.</param>
            <param name="task">Task to call</param>
            <param name="args">Arguments to task, if any</param>
            <returns>Generated text as one big string, and final values of global variables.  Or null if the task failed.</returns>
        </member>
        <member name="M:Step.Module.Call(System.String,System.Object[])">
            <summary>
            Calls the named task with the specified arguments and returns the text it generates
            </summary>
            <param name="taskName">Name of the task</param>
            <param name="args">Arguments to task, if any</param>
            <returns>Generated text as one big string, and final values of global variables.  Or null if the task failed.</returns>
        </member>
        <member name="M:Step.Module.CallPredicate(Step.State,System.String,System.Object[])">
            <summary>
            Calls the named task with the specified arguments as a predicate and returns true if it succeeds
            This call will fail if the task attempts to generate output.
            </summary>
            <param name="state">Global variable bindings to use in the call, if any.</param>
            <param name="taskName">Name of the task</param>
            <param name="args">Arguments to task, if any</param>
        </member>
        <member name="M:Step.Module.CallPredicate(System.String,System.Object[])">
            <summary>
            Calls the named task with the specified arguments as a predicate and returns true if it succeeds
            This call will fail if the task attempts to generate output.
            </summary>
            <param name="taskName">Name of the task</param>
            <param name="args">Arguments to task, if any</param>
        </member>
        <member name="M:Step.Module.CallFunction``1(Step.State,System.String,System.Object[])">
            <summary>
            Calls the named task with the specified arguments as a function and returns the value of its last argument
            This call will fail if the task attempts to generate output.
            </summary>
            <param name="state">Global variable bindings to use in the call, if any.</param>
            <param name="taskName">Name of the task</param>
            <param name="args">Arguments to task, if any</param>
        </member>
        <member name="M:Step.Module.CallFunction``1(System.String,System.Object[])">
            <summary>
            Calls the named task with the specified arguments as a function and returns the value of its last argument
            This call will fail if the task attempts to generate output.
            </summary>
            <param name="taskName">Name of the task</param>
            <param name="args">Arguments to task, if any</param>
        </member>
        <member name="M:Step.Module.LoadDirectory(System.String,System.Boolean)">
            <summary>
            Load all source files in the specified directory
            </summary>
            <param name="path">Path for the directory</param>
            <param name="recursive">If true, load files from all directories in the subtree under path</param>
        </member>
        <member name="M:Step.Module.LoadDefinitions(System.String)">
            <summary>
            Load the definitions in the specified file
            </summary>
            <param name="path">Path to the file</param>
        </member>
        <member name="M:Step.Module.LoadDefinitions(Step.Parser.DefinitionStream)">
            <summary>
            Load the method definitions from stream into this module
            </summary>
        </member>
        <member name="M:Step.Module.AddDefinitions(System.String[])">
            <summary>
            Parse and add the method definitions to this module
            </summary>
        </member>
        <member name="M:Step.Module.FromDefinitions(System.String[])">
            <summary>
            Make a new module, then parse and add the specified method definitions.
            </summary>
        </member>
        <member name="M:Step.Module.ParseAndExecute(System.String,Step.State)">
            <summary>
            Parse and run the specified code
            </summary>
            <param name="code">Code to run.  This will be used as the RHS of a method for the task TopLevelCall</param>
            <param name="state">State in which to execute the task.</param>
            <returns>Text output of the task and the resulting state</returns>
        </member>
        <member name="M:Step.Module.ParseAndExecute(System.String)">
            <summary>
            Parse and run the specified code
            </summary>
            <param name="code">Code to run.  This will be used as the RHS of a method for the task TopLevelCall</param>
            <returns>Text output of the task</returns>
        </member>
        <member name="M:Step.Module.AddBindHook(Step.Module.BindHook)">
            <summary>
            Add a procedure to call when a variable isn't found.
            If the procedure returns a value for it, that value is added to the module.
            </summary>
            <param name="hook">Procedure to use to import variables</param>
        </member>
        <member name="M:Step.Module.Warnings">
            <summary>
            Returns any warnings found by code analysis
            </summary>
        </member>
        <member name="M:Step.Module.TaskCalls(Step.Interpreter.CompoundTask,System.Object)">
            <summary>
            True if caller has a method that calls callee
            </summary>
            <param name="caller">Caller (must be a CompoundTask)</param>
            <param name="callee">Target of call (can be a CompoundTask or a primitive task, i.e. a delegate)</param>
        </member>
        <member name="M:Step.Module.StackTrace(Step.Interpreter.BindingList{Step.Interpreter.LogicVariable})">
            <summary>
            Return a trace of the method calls from the current frame.
            </summary>
        </member>
        <member name="T:Step.Module.TraceHandler">
            <summary>
            An event handler to be called on every method call.
            Used to implement single-stepping in a debugger
            </summary>
        </member>
        <member name="F:Step.Module.Trace">
            <summary>
            An event handler to be called on every method call.
            Used to implement single-stepping in a debugger
            </summary>
        </member>
        <member name="T:Step.Module.MethodTraceEvent">
            <summary>
            Which event is being traced (a call, success, or failure)
            </summary>
        </member>
        <member name="F:Step.Module.MethodTraceEvent.None">
            <summary>
            No recent trace event.
            </summary>
        </member>
        <member name="F:Step.Module.MethodTraceEvent.Enter">
            <summary>
            The arguments have been matched to the head of this method and we will now try running its body
            </summary>
        </member>
        <member name="F:Step.Module.MethodTraceEvent.Succeed">
            <summary>
            The method succeeded
            </summary>
        </member>
        <member name="F:Step.Module.MethodTraceEvent.MethodFail">
            <summary>
            The method failed
            </summary>
        </member>
        <member name="F:Step.Module.MethodTraceEvent.CallFail">
            <summary>
            The call completely failed
            </summary>
        </member>
        <member name="M:Step.Module.ToString">
            <inheritdoc />
        </member>
        <member name="T:Step.StateVariableName">
            <summary>
            An object representing the name of a variable held in a Module
            This does not store the value itself; it's just a key to the
            tables in the Modules.  So it's like a symbol in lisp.
            </summary>
        </member>
        <member name="F:Step.StateVariableName.SymbolTable">
            <summary>
            Table mapping names to existing global variables
            </summary>
        </member>
        <member name="M:Step.StateVariableName.Named(System.String)">
            <summary>
            Return the unique global variable with this name.
            Creates and stores the variable if necessary.
            </summary>
            <param name="name">Name for the variable</param>
        </member>
    </members>
</doc>
