initially:
    [set CurrentScene = test]
    [set AddTemp = empty]
    [set Test = none]
[end]

Br: [NewLine]

[predicate]
ChoiceInList [?frag ?choice_id] ?list:
    [Member ?m ?list]
    [= ?m [?frag ?choice_id]]
[end]

# Call ?call one time and return the result but reset variables and text output
# Example usage: 
#   [Backtrack [SetA ?args] ?result]
# This would call [SetA ?args ?result] exactly one time and bind the the final argument to ?result
Backtrack ?call ?result:
    [FindAll ?intermediate_result [BacktrackHelper ?call ?intermediate_result] [?result]]
[end]
BacktrackHelper ?call ?result:
    [ExactlyOnce [Call ?call ?result]]
[end]

# Custom list operations

# Add an element to a list
Add ?element ?list ?new_list:
    [set AddTemp = ?list]
    [AddHelper ?element]
    [= ?new_list AddTemp]
[end]
AddHelper ?element:
    [add ?element AddTemp]
[end]

SetUnion ?l1 ?l2 ?union:
    [set AddTemp = empty]
    [ForEach [Member ?x ?l1] [AddHelper ?x]]
    [ForEach [Member ?y ?l2] [Not [Member ?y ?l1]] [AddHelper ?y]]
    [= ?union AddTemp]
[end]

SetIntersection ?l1 ?l2 ?int:
    [set AddTemp = empty]
    [ForEach [Member ?x ?l1] [Member ?x ?l2] [AddHelper ?x]]
    [= ?int AddTemp]
[end]

Cat ?l1 ?l2 ?cat:
    [set AddTemp = empty]
    [ForEach [Member ?x ?l1] [AddHelper ?x]]
    [ForEach [Member ?y ?l2] [AddHelper ?y]]
    [= ?cat AddTemp]
[end]

Flatten2D ?list empty: [Length ?list 0]
Flastten2D ?list empty: [NotAny [InnerMember ?m ?list]]
Flatten2D ?list ?flattened:
    [FindAll ?member [InnerMember ?member ?list] ?flattened]
[end]
[predicate]
InnerMember ?m ?list:
    [Member ?sublist ?list] [Member ?m ?sublist]
[end]

Reverse ?list ?reversed:
    [set AddTemp = empty]
    [ForEach [Member ?x ?list] [AddHelper ?x]]
    [= ?reversed AddTemp]
[end]

[predicate]
ToTuple ?a ?b ?tuple:
    [= ?tuple [?a ?b]]
[end]

[predicate] # Extra logic to handle things like tuples
InList ?tuple ?list: [Member ?m ?list] [= ?m ?tuple]

RemoveFromList ?m ?list ?without:
    [NotAny 
        [Member ?n ?list]
        [= ?n ?m]
    ]
    [Throw RemoveFromList: element not in list ?m ?list]
[end]
RemoveFromList ?m ?list ?without:
    [FindAll ?n [Begin [Member ?n ?list] [Not [= ?m ?n]]] ?without]
[end]

# Slower than RemoveFromList
RemoveTupleFromList ?tuple ?list ?without:
    [NotAny 
        [Member ?m ?list]
        [= ?m ?tuple]
    ]
    [Throw RemoveTupleFromList: element not in list ?tuple ?list]
[end]
RemoveTupleFromList ?tuple ?list ?without:
    [FindAll ?n [Begin [Member ?n ?list] [Different ?tuple ?n]] ?without]
[end]


Last ?last ?list:
    [Reverse ?list ?reversed]
    [set Reversed = ?reversed]
    [removeNext ?last Reversed]
[end]