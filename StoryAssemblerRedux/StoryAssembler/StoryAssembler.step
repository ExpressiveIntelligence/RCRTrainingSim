Author: Alex

# Original StoryAssembler example frag: https://github.com/LudoNarrative/StoryAssembler/wiki/Creating-Scene-Content

# Mention ?x: [Write ?x]

## Define the fragment attributes ##

# Required predicates
predicate Fragment ?frag ?scene. 
predicate Effects ?frag.
predicate Conditions ?frag.

# Optional predicates
predicate Content ?frag.
predicate Speaker ?frag ?speaker.
predicate ChoiceLabel ?frag.
predicate ChoiceSpec ?frag ?choice_id.
predicate GoToChoice ?frag ?target_frag.
predicate ExistsChoiceLabel ?frag.

# Fragment fluents set during execution
fluent Expanded ?fragment.
fluent Reusable ?fragment.
predicate Available ?fragment.

## End fragment attributes ##

# Additional tasks and predicates
task RenderFragment ?fragment.
predicate TopLevelFragment ?fragment.


# Scene attributes and functions
predicate Scene ?scene.
task InitScene ?scene.
predicate StartState ?scene.

# # A Want is an element in a story spec 
# A Want is attached to a scene, and can be fulfilled
# or unfullfilled
fluent Want ?scene ?want_id.
predicate Fulfilled ?want_id.

# Functions for retreiving wants
predicate FulfilledWant ?scene ?want_id.
predicate UnFulfilledWant ?scene ?want_id.

# Is a story spec finished? (all wants fulfilled)
predicate CompleteStorySpec ?scene.
# Or is it incomplete?
predicate IncompleteStorySpec ?scene.

# TODO Functions
AddWishListItem ?fragment. # TODO https://github.com/LudoNarrative/StoryAssembler/wiki/Authoring-Patterns
Request ?fragment. # TODO https://github.com/LudoNarrative/StoryAssembler/wiki/Authoring-Patterns#fragment-available-both-as-choice-and-dynamically

TopLevelFragment ?frag: [Fragment ?frag ?] [Not [ExistsChoiceLabel ?frag]] # If it has a choice label it is not a top level fragment

RenderFragment ?frag:
    Rendered: ?frag
[end]

ExistsChoiceLabel ?frag: [IgnoreOutput [ChoiceLabel ?frag]]

Available ?fragment: [Reusable ?fragment]
Available ?fragment: [Not [Expanded ?fragment]]


[predicate]
PrintFinishState ?scene:
    [CompleteStorySpec ?scene]
    Congrats you're done.
[end]
PrintFinishState ?scene:
    [IncompleteStorySpec ?scene]
    You are not done.
[end]
PrintFinishState ?scene:
    Error with finish state check...
[end]

InitScene ?scene:
    [InitialSceneState ?scene]
[end]

UnFulfilledWant ?scene ?want:
    [Want ?scene ?want]
    [Not [Fulfilled ?want]]
[end]

FulfilledWant ?scene ?want:
    [Want ?scene ?want]
    [Fulfilled ?want]
[end]

IncompleteStorySpec ?scene:
    [UnFulfilledWant ?scene ?want]
[end]

CompleteStorySpec ?scene:
    [Scene ?scene] # find a scene with at least one attached want (ask michael about why this line is necessary, although it is intuitive)
    [Not [IncompleteStorySpec ?scene]]
[end]

# might want to count how many are true and then purposely fail
[predicate]
EffectMakesWantTrue ?fragment ?want_id: 
    [Want ?scene ?want_id]
    [Not [Fulfilled ?want_id]]
    [Effects ?fragment]
    [Fulfilled ?want_id]
[end]

Visit ?frag:
    [Fragment ?frag ?]      # without this line, ?frag may not be ground...
    [now [Expanded ?frag]]
    [Effects ?frag]
[end]

# There are three types of choices: 
# 1. GoTo: 
#       Go to a specific fragment based on its id
# 2. ChoiceSpec: 
#       Find a fragment that satisfies the choice spec 
#       Each choice must have a choice label
# 3. TopLevel: 
#       Find a fragment that does not have a choice label

# Returns a posible next fragment from the current fragment ?source_frag
# Side Effect: SatisfiableChoiceSpec will apply the effects of the new fragment
# choice_id: will be null unless there is an associated choice_id, ie the choice type is a ChoiceSpec
predicate AvailableNextFragment ?source_frag ?choice. # a choice is a [?target_frag ?choice_id] tuple

[predicate]
AvailableNextFragment ?source_frag [?target_frag null]: [AvailableGoTo ?source_frag ?target_frag]
AvailableNextFragment ?source_frag [?target_frag ?choice_id]: [SatisfiableChoiceSpec ?source_frag ?choice_id ?target_frag]
AvailableNextFragment ?source_frag [?target_frag null]: # TODO this is really slow because of the checks and could probably be sped up
    [NotAny [AvailableGoTo ?source_frag ?]] 
    [NotAny [SatisfiableChoiceSpec ?source_frag ? ?]] 
    [AvailableTopLevelFragment ?target_frag]
[end]

# Returns true if ?satisfying_frag satisfies ?source_frag's choice ?choice_id
[predicate]
SatisfiableChoiceSpec ?source_frag ?choice_id ?satisfying_frag: 
    [ExistsChoiceLabel ?satisfying_frag]        # the new fragment must have a choice label
    [Conditions ?satisfying_frag]
    [Effects ?satisfying_frag]            # apply the effects of the new frag
    [ChoiceSpec ?source_frag ?choice_id]  # see if they satisfy the choice spec of the source frag
    [Available ?satisfying_frag]          # TODO I can't put this at the top even though it would speedup
[end]

[predicate]
AvailableTopLevelFragment ?frag:
    [TopLevelFragment ?frag]    # must not have a choice label
    [Available ?frag]
    [Conditions ?frag]
[end]

[predicate]
AllAvailableTopLevelFragments ?fragments:
    [FindAll ?frag [AvailableTopLevelFragment ?frag] ?fragments]
[end]

[predicate]
AvailableGoTo ?source_frag ?target_frag:
    [GoToChoice ?source_frag ?target_frag]
    [Available ?target_frag]
    [Conditions ?target_frag]
[end]

[predicate]
AllGoToChoices root empty.  # there is no source frag
AllGoToChoices ?source_frag ?fragments:
    [Different ?source_frag root]
    [FindAll ?frag [AvailableGoTo ?source_frag ?frag] ?fragments]
[end]

AllSatisfiableChoices root empty. # there is no source frag
AllSatisfiableChoices ?source_frag ?satisfying_frag_list: # TODO this doesn't return the choice_id. Do we need this?
    [Different ?source_frag root]
    [FindAll ?frag [SatisfiableChoiceSpec ?source_frag ?choice_id ?frag] ?satisfying_frag_list]
[end]