Author: Alex

## Define the Fragment attributes ##

# Original StoryAssembler example frag: https://github.com/LudoNarrative/StoryAssembler/wiki/Creating-Scene-Content

# Required predicates
predicate Fragment ?frag ?scene. 
predicate Effects ?frag.
predicate Conditions ?frag.

# Optional predicates
predicate Content ?frag.
predicate Speaker ?frag ?speaker.
predicate ChoiceLabel ?frag.
task ChoiceSpec ?frag ?choice_id.
task GoToChoice ?frag ?target_frag.

# Fragment fluents set during execution
fluent Expanded ?fragment.
fluent Reusable ?fragment.

AddWishListItem ?fragment. # TODO https://github.com/LudoNarrative/StoryAssembler/wiki/Authoring-Patterns

Request ?fragment. # TODO https://github.com/LudoNarrative/StoryAssembler/wiki/Authoring-Patterns#fragment-available-both-as-choice-and-dynamically

TopLevelFragment ?frag: [Fragment ?frag ?] [Not [ChoiceLabel ?frag]] # If it has a choice label it is not a top level fragment

[predicate]
RenderFragment ?frag:
    Rendered: ?frag
[end]

# [predicate]
# AvailableFragment ?fragment ?scene: [Fragment ?fragment ?scene] [Conditions ?fragment]
# [predicate]
# AvailableUnexploredFragment ?fragment ?scene: [AvailableFragment ?fragment ?scene] [Not [Expanded ?fragment]]

[predicate]
# Available ?fragment: [Reusable ?fragment]
Available ?fragment: [Not [Expanded ?fragment]]

# Scene stuff
predicate Scene ?scene.
predicate InitScene ?scene.
predicate StartState ?scene.

# # A Want is an element in a story spec 
# A Want is attached to a scene, and can be fulfilled
# or unfullfilled
fluent Want ?scene ?want_id.
predicate Fulfilled ?want_id.

# Functions for retreiving wants
predicate FulfilledWant ?scene ?want_id.
predicate UnFulfilledWant ?scene ?want_id.

# Is a story spec finished? (all wants fulfilled)
predicate CompleteStorySpec ?scene.
# Or is it incomplete?
predicate InCompleteStorySpec ?scene.

[predicate]
PrintFinishState ?scene:
    [CompleteStorySpec ?scene]
    Congrats you're done.
[end]
PrintFinishState ?scene:
    [InCompleteStorySpec ?scene]
    You are not done.
[end]
PrintFinishState ?scene:
    Error with finish state check...
[end]

[predicate]
InitScene ?scene:
    [InitialSceneState ?scene]
[end]

[predicate]
UnFulfilledWant ?scene ?want:
    [Want ?scene ?want]
    [Not [Fulfilled ?want]]
[end]

[predicate]
FulfilledWant ?scene ?want:
    [Want ?scene ?want]
    [Fulfilled ?want]
[end]

[predicate]
InCompleteStorySpec ?scene:
    [UnFulfilledWant ?scene ?want]
[end]

[predicate]
CompleteStorySpec ?scene:
    [Scene ?scene] # find a scene with at least one attached want (ask michael about why this line is necessary, although it is intuitive)
    [Not [InCompleteStorySpec ?scene]]
[end]

# MyList = empty
# [add MyList [thing]]

# might want to count how many are true and then purposely fail
[predicate]
EffectMakesWantTrue ?fragment ?want: 
    [Want ?scene ?want_id]
    [Not [Fulfilled ?want_id]]
    [Effects ?fragment]
    [Fulfilled ?want_id]
[end]

Visit ?frag:
    [Fragment ?frag ?]      # without this line, ?frag may not be ground...
    [now [Expanded ?frag]]
    [Effects ?frag]
[end]

# Algorithms
Start ?frag:
    [BestFrag root ?frag ?score]
    [Visit ?frag]
    # [RenderFragment ?frag]
    ?frag/Write
[end]
Start ?frag:
    Error
[end]

Continue ?cur_frag ?next_frag:
    [BestFrag ?cur_frag ?path ?score]
    [Visit ?next_frag]
    [RenderFragment ?next_frag]
[end]
Continue ?cur_frag ?next_frag: 
    [Start ?next_frag]
[end]
Continue ?cur_frag ?next_frag:
    Error
[end]