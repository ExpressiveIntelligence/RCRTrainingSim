Initialize ?scene:
    [InitializeScene ?scene]
    [InitializeChoices]
    # Initialized ^CurrentScene.
    # Currently at fragment ^CurrentFragment. [Br]
    [Check]
[end]

InitializeScene ?scene: 
    [set CurrentFragment = root]
    [Scene ?scene]
    [set CurrentScene = ?scene]
    [InitScene CurrentScene]
[end]

Check:
    [ForEach [ChoiceLabel ?f] [CheckNoFrag ?f]]
    [ForEach [Content ?f] [CheckNoFrag ?f]]
[end]

CheckNoFrag ?f:
    [Not [Fragment ?f CurrentScene]]
    Warning: no fragment found for ?f
[end]
CheckNoFrag ?f.


InitializeChoices:
    [BestChoices CurrentFragment ?next_best]
    [set NextBestChoices = ?next_best]
[end]

PrintChoices:
    [DoAll [Member ?choice NextBestChoices] [WriteVerbatim ?choice]]
[end]

BestPath:
    # TODO render the best path, which should be saved somewhere
[end]

ShowHelp:
    Command Line Interface: [Paragraph]
    Press "s" to save state between executions.

    Commands: [Paragraph]

    \[Initialize\ \?scene\] [Paragraph] Must be called before any other |StoryAssembler.step| task. Sets up the |?scene| and sets the current fragment to an empty root. Note: it's fine to call this task with an unbound |?scene|. Example: \[Initialize maze\] \[Render\] [Paragraph]
    |[Select ?choice_id]| [Paragraph] Makes a choice and render the result (for command line purposes only). Example \[Select welcome\] [Paragraph]
    \[Render\] [Paragraph] Render the current fragment and scene content, and display choices. [Paragraph]
    |[MakeChoice \?\choice_id]| [Paragraph] Specify the choice to make, based on the choice id, which will not be shown to the end user.  [Paragraph]
    |[PrintChoices]| [Paragraph] Print the choices available. [Paragraph]
[end]

# Used for the CLI only
Select ?choice_id:
    [MakeChoice ?choice_id]
    [Show] # Render the result for humans
[end]

MakeChoice ?choice_id:
    [Var ?choice_id]
    [Throw |MakeChoice needs a bound variable:| ?choice_id]
[end]
MakeChoice ?choice_id:
    [GoToChoice CurrentFragment ?choice_id]
    [Fragment ?choice_id CurrentScene]
    [Not [TestConditions ?choice_id]]
    [Throw Conditions not met for ?choice_id]
[end]
MakeChoice ?choice_id:
    [GoToChoice CurrentFragment ?choice_id]
    [Fragment ?choice_id CurrentScene] # TODO no fragment case
    [UpdateCurrentFragment ?choice_id]
[end]
MakeChoice ?choice_id:
    [GetFromNextBestChoices ?fragment_id ?choice_id]
    [UpdateCurrentFragment ?fragment_id]
[end]
MakeChoice ?choice_id:
    [AvailableTopLevelFragment ?choice_id] # TODO I think this logic needs to be thought through
    [GetFromNextBestChoices ?choice_id false]
    [UpdateCurrentFragment ?choice_id]
[end]

UpdateCurrentFragment ?fragment_id:
    [TestConditions ?fragment_id]
    [Visit ?fragment_id]
    [set CurrentFragment = ?fragment_id]
    [BestChoices ?fragment_id ?next_best]
    [set NextBestChoices = ?next_best]
[end]
UpdateCurrentFragment ?fragment_id:
    [Not [TestConditions ?fragment_id]]
    [Throw Conditions not met for ?fragment_id]
[end]

[predicate]
GetFromNextBestChoices ?next_fragment ?choice_id:
    [ChoiceInList [?next_fragment ?choice_id] NextBestChoices]
[end]
