Initialize ?scene: 
    [set ^CurrentFragment = root]
    [set ^CurrentScene = ?scene]
    [InitScene ^CurrentScene]
    [BestChoices ^CurrentFragment ?next_best]
    [set ^NextBestChoices = ?next_best]
    Initial Scene State: ^CurrentFragment ^CurrentScene [Br] # ^NextBestChoices
[end]

MakeChoice ?choice_id:
    [Var ?choice_id]
    [Throw "MakeChoice called with unbound variable"]
[end]
MakeChoice ?choice_id:
    [Not [Fragment ?choice_id ^CurrentScene]]
    [Not [ConditionalChoice ^CurrentFragment ?choice_id]]
    [Throw "No fragment or conditional choice found for" ^CurrentScene ^CurrentFragment ?choice_id]
[end]
MakeChoice ?choice_id:
    [GoToChoice ^CurrentFragment ?choice_id]
    [ConditionalChoice ^CurrentFragment ?choice_id]
    [Throw "Ambiguous choice ID. ConditionalChoice ID's and GoToChoice fragments should not overlap within a fragment" ^CurrentScene ^CurrentFragment ?choice_id]
[end]
MakeChoice ?choice_id:
    [GoToChoice ^CurrentFragment ?choice_id]
    [Fragment ?choice_id ^CurrentScene]
    [Not [TestConditions ?choice_id]]
    [Throw "Conditions not met for " ?choice_id]
[end]
MakeChoice ?choice_id:
    [GoToChoice ^CurrentFragment ?choice_id]
    [Fragment ?choice_id ^CurrentScene] # TODO no fragment case
    [UpdateCurrentFragment ?choice_id]
[end]
MakeChoice ?choice_id:
    [ConditionalChoice ^CurrentFragment ?choice_id] # TODO I think this logic needs to be thought through
    [GetFromNextBestChoices ?fragment_id ?choice_id]
    [UpdateCurrentFragment ?fragment_id]
[end]
MakeChoice ?choice_id:
    [AvailableTopLevelFragment ?choice_id] # TODO I think this logic needs to be thought through
    [GetFromNextBestChoices ?choice_id false]
    [UpdateCurrentFragment ?choice_id]
[end]

UpdateCurrentFragment ?fragment_id:
    [TestConditions ?fragment_id]
    [Visit ?fragment_id]
    [set ^CurrentFragment = ?fragment_id]
    [BestChoices ?fragment_id ?next_best]
    [set ^NextBestChoices = ?next_best]
[end]
UpdateCurrentFragment ?fragment_id:
    [Not [TestConditions ?fragment_id]]
    [Throw "Conditions not met for " ?fragment_id]
[end]

GetFromNextBestChoices ?next_fragment ?choice_id:
    [ChoiceInList [?next_fragment ?choice_id] ^NextBestChoices]
[end]
GetFromNextBestChoices ?next_fragment ?choice_id:
    [Length ^NextBestChoices 0]
    [Throw "Next best choices is empty..."]
[end]
GetFromNextBestChoices ?next_fragment ?choice_id:
    [Not [ChoiceInList [?next_fragment ?choice_id] ^NextBestChoices]]
    [Throw ?next_fragment ?choice_id]
    # [Throw [?next_fragment ?choice_id] "is not a valid choice for" ^CurrentFragment Next best choices are ^NextBestChoices]
[end]

Render:
    [RenderScene ^CurrentScene][Br]
    [RenderFragment ^CurrentFragment][Br]
    [RenderChoices ?frag ^NextBestChoices]
[end]

RenderScene ?scene:
    You see: [DoAll [PrintCharacter ?id ?scene]]
[end]

RenderFragment ?frag: [= ?frag root] Not viewing a fragment (at root).
RenderFragment ?frag:
    [Different ?frag root]
    [Content ?frag]
[end]

RenderChoices ?frag ?choices:
    [Length ?choices ?l] ?l Choices: [Br] [DoAll [Member ?c ?choices] [RenderChoice ?c]]
[end]

RenderChoice [?frag ?choice_id]: |[| [ChoiceLabel ?frag] |]| [GetID [?frag ?choice_id]] 
RenderChoice ?choice: |[Continue]|\ -> [GetID ?choice] [Br]

GetID [?frag ?choice_id]: [Different ?choice_id false] ?choice_id/Write
GetID [?frag ?choice_id]: [Fragment ?frag ^CurrentScene] ?frag/Write
GetID ?x: ?x