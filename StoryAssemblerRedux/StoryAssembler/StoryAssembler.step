# Author: Alex

# # Foo: global variable test
# # Button "Assemble Story" [StoryAssembler ?].

# # [main]
# # Test: test.

# # Button 
# [main]
# StoryAssembler ?frag:
#     [AvailableFragment ?frag ^CurrentScene]
#     [PrintFragment ?frag]
#     [Effects ?frag]
# [end]

# [predicate]
# PrintFragment ?frag:
#     --Fragment--
#     [Paragraph]
#     [Fragment ?frag ?scene]
#     [PrintContent ?frag]
#     [Paragraph]
#     [PrintChoices ?frag]
#     [Paragraph]
#     [PrintConditions ?frag]
#     [PrintEffects ?frag]
#     [PrintChoiceLabel ?frag]
# [end]

# [predicate]
# PrintContent ?frag:
#     ?frag/Speaker/Write Speaking: [Content ?frag]
# [end]
# PrintContent ?frag:
#     [Content ?frag]
# [end]
# PrintContent ?frag:
#     ?frag # If there is no content, just print the fragment name
# [end]

# PrintChoices ?frag:
#     [Choices ?frag]
# [end]
# PrintChoices ?frag.

# PrintChoiceLabel ?frag:
#     [ChoiceLabel ?frag]
# [end]
# PrintChoiceLabel ?frag.

# # PrintConditions ?frag:
# #     Conditions: [Conditions ?frag]
# # [end]
# PrintConditions ?frag.

# # PrintEffects ?frag:
# #     Effects: [Effects ?frag]
# # [end]
# PrintEffects ?frag.


# Define the Fragment attributes as predicates
predicate Fragment ?frag ?scene.
predicate Effects ?frag. # Effects must be declared
predicate Conditions ?frag.
predicate Content ?frag.
predicate Speaker ?frag ?speaker.
predicate Choices ?frag. 
predicate ChoiceLabel ?frag.
predicate Choice ?frag ?speaker ?n.
fluent Expanded ?fragment.

[predicate]
AvailableFragment ?fragment ?scene: [Fragment ?fragment ?scene] [Conditions ?fragment]
[predicate]
AvailableUnexploredFragment ?fragment ?scene: [AvailableFragment ?fragment ?scene] [Not [Expanded ?fragment]]

# Scene stuff
predicate Scene ?scene.
predicate InitScene ?scene.
predicate StartState ?scene.

# # A Want is an element in a story spec 
# A Want is attached to a scene, and can be fulfilled
# or unfullfilled
fluent Want ?scene ?want_id.
predicate Fulfilled ?want_id.

# Functions for retreiving wants
predicate FulfilledWant ?scene ?want_id.
predicate UnFulfilledWant ?scene ?want_id.

# Is a story spec finished? (all wants fulfilled)
predicate CompleteStorySpec ?scene.
# Or is it incomplete?
predicate InCompleteStorySpec ?scene.

[predicate]
PrintFinishState ?scene:
    [CompleteStorySpec ?scene]
    Congrats you're done.
[end]
PrintFinishState ?scene:
    [InCompleteStorySpec ?scene]
    You are not done.
[end]
PrintFinishState ?scene:
    Error with finish state check...
[end]

[predicate]
InitScene ?scene:
    [= 0 0]
    [InitialSceneState ?scene]
    Initialized Scene: ?scene
    [Paragraph]
[end]

[predicate]
UnFulfilledWant ?scene ?want:
    [Want ?scene ?want]
    [Not [Fulfilled ?want]]
[end]

[predicate]
FulfilledWant ?scene ?want:
    [Want ?scene ?want]
    [Fulfilled ?want]
[end]

[predicate]
InCompleteStorySpec ?scene:
    [UnFulfilledWant ?scene ?want]
[end]

[predicate]
CompleteStorySpec ?scene:
    [Scene ?scene] # find a scene with at least one attached want (ask michael about why this line is necessary, although it is intuitive)
    [Not [InCompleteStorySpec ?scene]]
[end]

# MyList = empty
# [add MyList [thing]]