Author: Alex

# Original StoryAssembler example frag: https://github.com/LudoNarrative/StoryAssembler/wiki/Creating-Scene-Content

# Mention ?x: [Write ?x]

## Define the fragment attributes ##

# Required predicates
predicate Fragment ?frag ?scene. 
predicate ApplyEffects ?frag.
predicate Effects ?frag.
predicate Conditions ?frag.

# Optional predicates
predicate Content ?frag.
predicate Speaker ?frag ?speaker.
predicate ChoiceLabel ?frag.
predicate ConditionalChoice ?frag ?choice_id.
predicate GoToChoice ?frag ?target_frag.

# A request is TODO
# A request may be a conditional request or a goto request
predicate Request ?frag ?request_type ?go_to_or_condition.

# Fragment fluents set during execution

# TODO Document
fluent Expanded ?fragment ?scene.
# TODO Document & test
fluent Reusable ?fragment ?scene.

# Check if a fragment is available to be visited. 
# The conditions to be avialiable is that the fragment must be reusable or not expanded 
predicate Available ?fragment.

## End fragment attributes ##

# Additional tasks and predicates

# Check if a fragment has a choice label, but does not print the text of the choice label
predicate ExistsChoiceLabel ?frag.

task RenderFragment ?fragment.
predicate TopLevelFragment ?fragment.

# Scene attributes and functions
predicate Scene ?scene.
task InitScene ?scene.
predicate StartState ?scene.

# # A Want is an element in a story spec 
# A Want is attached to a scene, and can be fulfilled
# or unfullfilled
fluent Want ?scene ?want_id.
predicate Fulfilled ?want_id.

# Functions for retreiving wants
predicate FulfilledWant ?scene ?want_id.
predicate UnFulfilledWant ?scene ?want_id.

# Is a story spec finished? (all wants fulfilled)
predicate CompleteStorySpec ?scene.
# Or is it incomplete?
predicate IncompleteStorySpec ?scene.

# TODO Functions
predicate AddWishListItem ?fragment. # TODO https://github.com/LudoNarrative/StoryAssembler/wiki/Authoring-Patterns
# TODO document
predicate Request ?fragment ?request_type ?go_to_or_condition.

TopLevelFragment ?frag: [Fragment ?frag ^CurrentScene] [Not [ExistsChoiceLabel ?frag]] # If it has a choice label it is not a top level fragment

RenderFragment ?frag:
    Rendered: ?frag
[end]

[predicate]
ExistsChoiceLabel ?frag: [Fragment ?frag ^CurrentScene] [IgnoreOutput [ChoiceLabel ?frag]]

[predicate]
SatisfiesConditionalChoice ?frag ?choice_id:
    [ConditionalChoice ?frag ?choice_id]
    [Fragment ?frag ^CurrentScene]
[end]

Available ?fragment: [Reusable ?fragment ^CurrentScene]
Available ?fragment: [Not [Expanded ?fragment ^CurrentScene]]

# [predicate]
# PrintFinishState ?scene:
#     [CompleteStorySpec ?scene]
#     Congrats you're done.
# [end]
# PrintFinishState ?scene:
#     [IncompleteStorySpec ?scene]
#     You are not done.
# [end]
# PrintFinishState ?scene:
#     Error with finish state check...
# [end]

InitScene ?scene:
    [InitialSceneState ?scene]
[end]

UnFulfilledWant ?scene ?want:
    [Want ?scene ?want]
    [Not [Fulfilled ?want]]
[end]

FulfilledWant ?scene ?want:
    [Want ?scene ?want]
    [Fulfilled ?want]
[end]

IncompleteStorySpec ?scene:
    [UnFulfilledWant ?scene ?want]
[end]

CompleteStorySpec ?scene:
    [Scene ?scene] # find a scene with at least one attached want (ask michael about why this line is necessary, although it is intuitive)
    [Not [IncompleteStorySpec ?scene]]
[end]

[predicate]
ApplyEffects ?frag:
    [Fragment ?frag ^CurrentScene]
    [Effects ?frag]
[end]

[predicate]
TestConditions ?frag:
    [Fragment ?frag ^CurrentScene]
    [Conditions ?frag]
[end]

# TODO unused 
[predicate]
EffectMakesWantTrue ?fragment ?want_id: 
    [Want ?scene ?want_id]
    [Not [Fulfilled ?want_id]]
    [ApplyEffects ?fragment]
    [Fulfilled ?want_id]
[end]

Visit ?frag:
    [Fragment ?frag ^CurrentScene]      # without this line, ?frag may not be ground...
    [now [Expanded ?frag ^CurrentScene]] # TODO: this is a side effect, but it is necessary for the planner to work
    [ApplyEffects ?frag]
[end]

# There are three types of choices: 
# 1. GoTo: 
#       Go to a specific fragment based on its id
# 2. ConditionalChoice: 
#       Find a fragment that satisfies the choice spec 
#       Each choice must have a choice label
# 3. TopLevel: 
#       Find a fragment that does not have a choice label

# Returns a posible next fragment from the current fragment ?source_frag
# Side Effect: AvailableConditionalChoice will apply the effects of the new fragment
# choice_id: will be false unless there is an associated choice_id, ie the choice type is a ConditionalChoice
predicate AvailableNextFragment ?source_frag ?choice. # a choice is a [?target_frag ?choice_id] tuple
# TODO if source_frag is not ground yet, ?args, rtype will not be either
# TODOO if we apply the effects here, it will be slow since it will grab all possible effects
[predicate]
AvailableNextFragment ?source_frag [?target ?choice_id]:
    [AvailableNextHelper ?source_frag [?target ?choice_id]]
[end]
AvailableNextFragment ?source_frag [?target_frag false]:
    # DODO do we need the notany checks?
    [AvailableTopLevelFragment ?target_frag]
[end]

[predicate]
AvailableNextHelper ?source_frag [?target ?choice_id]:
    # If the source fragment is a dynamic node, then we need to make a request for a satisfying fragment 
    # and begin the search from the fragment that completes the request. 
    # AssembleRequest will also apply the effects of the new fragment
    # If the source fragment is not a dynamic node, then we can begin the search from the source fragment 
    [AssembleRequest ?source_frag ?search_origin] 
    [AvailableChoice ?search_origin [?target ?choice_id]]
[end]

# All goto and conditional choices
[predicate]
AvailableChoice ?origin [?target_frag false]:
    [AvailableGoTo ?origin ?target_frag]
[end]
[predicate]
AvailableChoice ?origin [?target_frag ?choice_id]:
    [AvailableConditionalChoice ?origin ?choice_id ?target_frag]
[end]

# Check that the ?source frag is a dynamic node
# If so, execute a request for a satisfying fragment
# and apply its effects
# Otherwise, return the source fragment
predicate AssembleRequest ?source_frag ?response.
AssembleRequest ?source_frag ?response:
    [Request ?source_frag ?request_type ?args]
    # Make the request for a completion node and apply its effects
    [MakeRequest ?source_frag ?request_type ?args ?response]
[end]
AssembleRequest ?source_frag ?source_frag: [Fragment ?source_frag ^CurrentScene] [NotAny [Request ?source_frag ? ?]]

# SIDE EFFECT: potentially applies the Effects of ?response
[predicate]
MakeRequest ?source goto ?go_to_frag ?go_to_frag:
    # If we've reached here we know we have a dynamic fragment with a goto request
    [AvailableForRequest ?source ?go_to_frag]
[end]
MakeRequest ?source condition ?search_condition ?response:
    [AvailableForRequest ?source ?response]
    [ApplyEffects ?response]
    [Call ?search_condition] # Check the necessary condition # TODO make sure this is checking using the CheckCondition rather than Condition
[end]

[predicate]
AvailableForRequest ?requesting ?response:
    [NotAny [Request ?response ? ?]] # TODO I don't think we want to chain responses? If not, we can get rid of the difference check
    [TestConditions ?response]
    [Available ?response]
    # [Different ?requesting ?response]
[end]

[predicate]
AvailableGoTo ?source_frag ?target_frag:
    [GoToChoice ?source_frag ?target_frag]
    [Available ?target_frag]
    [TestConditions ?target_frag]
[end]

[predicate]
AllGoToChoices root empty.  # there is no source frag
AllGoToChoices ?source_frag ?fragments:
    [Different ?source_frag root]
    [FindAll ?frag [AvailableGoTo ?source_frag ?frag] ?fragments]
[end]

# Returns true if ?satisfying_frag satisfies ?source_frag's choice ?choice_id
[predicate]
AvailableConditionalChoice ?source_frag ?choice_id ?satisfying_frag: 
    [ExistsChoiceLabel ?satisfying_frag]        # the new fragment must have a choice label
    [TestConditions ?satisfying_frag]
    [ApplyEffects ?satisfying_frag]            # apply the effects of the new frag
    [SatisfiesConditionalChoice ?source_frag ?choice_id]  # see if they satisfy the choice spec of the source frag
    [Available ?satisfying_frag]          # TODO I can't put this at the top even though it would speedup
[end]

[predicate]
AvailableTopLevelFragment ?frag:
    [TopLevelFragment ?frag]    # must not have a choice label
    [Available ?frag]
    [TestConditions ?frag]
[end]

[predicate]
AllAvailableTopLevelFragments ?fragments:
    [FindAll ?frag [AvailableTopLevelFragment ?frag] ?fragments]
[end]