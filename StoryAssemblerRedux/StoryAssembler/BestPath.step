initially: 
    [set MaxDepth = 3] # The maximum depth of the search tree
[end]

# Exposed function headers
task BestChoices ?source_frag ?choices.

[predicate]
AllPathsFrom ?source_frag ?paths: [FindPaths [?source_frag false] empty ?paths] 

[predicate]
# TODO request best choices
# BestChoices ?frag ?choices:
#     [Request ?frag ?request_type ?args]  
#     [AllPathsFrom ?frag ?paths]
# [end]
BestChoices ?frag ?choices:
    # The case that there are no conditional choices.
    # We don't need to do a search, either return the GoTo choices
    # or if there aren't any, the top level choices instead.
    [NotAny [ConditionalChoice ?frag ?choice_id]]
    [AllGoToChoices ?frag ?goto_frags]
    [TopLevelChoicesIfNoOtherOption ?goto_frags ?top_level_frags]
    [Cat ?goto_frags ?top_level_frags ?choices]
[end]
BestChoices ?frag ?choices:
    [AllGoToChoices ?frag ?goto_frags]
    [AllPathsFrom ?frag ?paths]
    [BestConditionalChoices ?frag ?paths ?choice_spec_frags]
    [Cat ?goto_frags ?choice_spec_frags ?running_choices]
    [TopLevelChoicesIfNoOtherOption ?running_choices ?top_level_frags]
    [Cat ?running_choices ?top_level_frags ?choices]
[end]

[predicate]
BestConditionalChoices ?frag ?paths ?choices:
    [set ^PathsToCheck = ?paths]
    [set ^Choices = empty]
    [Member ?m ?paths] [ScoredPath ? ? ?m] # Assert that we have a list of paths
    [ForEach [ConditionalChoice ?frag ?choice_id] [AddNextBestChoice ?choice_id]]
    [= ?choices ^Choices]
[end]
BestConditionalChoices ?frag ?paths empty.

AddNextBestChoice ?choice_id:
    [Max ?value 
        [Member ?top_path ^PathsToCheck] 
        [ScoredPath ?value ?top_path] 
        [NextStepFulfillsChoice ?choice_id ?top_path ?best_frag]
    ]
    [add ?best_frag Choices]    

    # For the next round of searching, don't include the one we selected
    [RemoveFromList ^Path ^PathsToCheck ?new_paths]
    [set ^PathsToCheck = ?new_paths]
[end]

NextStepFulfillsChoice ?fulfilled_choice ?path ?target_frag:
    [set ^Path = ?path]
    [removeNext [?cur_frag ?] ^Path] [removeNext [?target_frag ?fulfilled_choice] ^Path]
[end]

[predicate]
TopLevelChoicesIfNoOtherOption ?other_choices ?choices: [Length ?other_choices 0] [AllAvailableTopLevelChoices ?choices]
TopLevelChoicesIfNoOtherOption ?other_choices empty. 

# Find all outgoing paths from ?frag and store them in the ^AllPaths global variable
# The wrapper for this Task is AllPathsFrom
# Example usage: [AllPathsFrom root ?paths]
[predicate]
FindPaths [?frag ?choice_id] ?path ?found_paths:
    [Var ?frag]
    [Throw FindPaths called with unbound frag]
[end]
FindPaths [?frag ?choice_id] ?path ?found_paths:
    [Var ?choice_id]
    [Throw FindPaths called with unbound choice_id]
[end]
FindPaths [?frag ?choice_id] ?path ?found_paths:
    [Length ?path ^MaxDepth]
    [ScorePath ?path ?scored_path]
    [= ?found_paths [?scored_path]]
[end]
FindPaths [?frag ?choice_id] ?path ?found_paths:
    # The current fragment is the top of a dynamic fragment and there are available fragments to complete it
    [Request ?frag ?request_type ?args] 
    [Visit ?frag]
    [FindUnique ?response [MakeRequest ?frag ?request_type ?args ?response] ?responses]
    [Add [?frag ?choice_id] ?path ?response_path]
    [FindAll ?paths_from_response
        [Begin 
            [Member ?response ?responses]
            [FindPaths [?response false] ?response_path ?paths_from_response]
        ]
        ?paths_from_responses
    ]
    [Flatten2D ?paths_from_responses ?found_paths]
[end]
FindPaths [?frag ?choice_id] ?path ?found_paths:
    # Handle the case where the current fragment is dynamic but there are no 
    # available fragments to complete it. This is a dead end, but its parent is a valid path.
    [Request ?frag ?type ?args]
    [Visit ?frag]
    [NotAny [MakeRequest ?frag ?type ?args ?response]] 
    [ScorePath ?path ?scored_path]
    [= ?found_paths [?scored_path]]
[end]
FindPaths [?frag ?choice_id] ?path ?found_paths:
    [NotAny [Request ?frag ? ?]] # The current frag is not a request
    [case ?frag] [Different root] : [Visit ?frag] [else] [end]
    [NotAny [AvailableNextFragment ?frag ?next_choice]] 
    [ScorePath ?path ?scored_path]
    [= ?found_paths [?scored_path]]
[end]
FindPaths [?frag ?choice_id] ?path ?paths_from_children:
    [NotAny [Request ?frag ? ?]] # The current frag is not a request
    [case ?frag] [Different root] : [Visit ?frag] [else]  [end]
    # All possible next fragments that can be selected are 'children' of the current fragment. Should backtrack all calls.
    [FindUnique ?next_choice [AvailableNextFragment ?frag ?next_choice] ?potential_choices]
    [FindAll ?paths_from_child 
        [FindAllPathsFromAChildOf ?potential_choices [?frag ?choice_id] ?path ?paths_from_child] 
        ?list_of_paths_from_children
    ]
    [Flatten2D ?list_of_paths_from_children ?paths_from_children]
[end]

[predicate]
FindAllPathsFromAChildOf ?choices ?current ?current_path ?paths_from_child:
    # TODO double check that we are actually getting all children and not just the first 
    [Not [Length ?choices 0]] # TODO the 0 was 'empty' and it seemed to work before...
    [Member ?child ?choices] # select a choice from the potential choices 
    [FindPathsForChild ?child ?current ?current_path ?paths_from_child]
[end]

[predicate]
FindPathsForChild ?child ?current ?current_path ?paths_from_child:
    # Construct the path to the child (not including the child)
    [Add ?current ?current_path ?child_path]  
    # Findall the paths from the child, store the result, and undo the state changes
    # This line does not Fail unless FindPaths fails
    [Backtrack [FindPaths ?child ?child_path] ?paths_from_child]
[end]