initially: 
    [set MaxDepth = 3]
    [set CurDepth = 0]
    [set MaxValue = 100]
[end]

Mention ?x: [Write ?x]

PrintAllSatisfyingChoices ?source_frag:
    [AllSatisfyingChoices ?source_frag ?specs]
    Potential choices from ?source_frag: ?specs
[end]

AllSatisfyingChoices ?source_frag ?satisfying_frag_list:
    [FindAll ?frag [SatisfyingChoiceSpec ?source_frag ?choice_id ?frag] ?satisfying_frag_list]
[end]

[predicate]
SatisfyingChoiceSpec ?source_frag ?choice_id ?satisfying_frag: 
    [ChoiceLabel ?satisfying_frag]        # the new fragment must have a choice label
    [Conditions ?satisfying_frag]
    [Effects ?satisfying_frag]            # apply the effects of the new frag
    [ChoiceSpec ?source_frag ?choice_id]  # see if they satisfy the choice spec of the source frag
    [Not [Expanded ?satisfying_frag]]     # TODO I can't put this at the top even though it would speedup
[end]

[predicate]
BestPath ?best_frag ?score:
    [Max ?score [ScoreFragment ?best_frag ?score]]
[end]

[predicate]
ScoreFragment ?frag ?score:
    # Get an avilable fragment in the scene
    [AvailableUnexploredFragment ?frag ^CurrentScene] 
    ?frag

    # Apply the fragment's effects
    [now [Expanded ?frag]]
    [Effects ?frag]

    # Score the current fragment
    [SearchAndScoreValidPaths ?frag ?score]
[end]
ScoreFragent none 0: 
    # Not sure this does anything useful
    No available fragment.
[end]

[predicate]
SearchAndScoreValidPaths ?frag ?score:
    # Don't need to keep recursing if we're at the max value
    [Value ?frag ?score]
    [>= ?score ^MaxValue]
    Frag ?frag at max value ?score
[end]
SearchAndScoreValidPaths ?frag ?score:
    # Called after applying the fragment's effects

    # Enforce recursion limit
    [>= ^MaxDepth ^CurDepth] 
    [inc ^CurDepth]

    [Value ?frag ?cur_frag_value] # get the value of our current state

    Frag ?Frag

    # Recursively call BestPath to get the best outgoing path
    [BestPath ?new_frag ?chain_value]
    # Get the value of this fragment
    [set ?score = ?cur_frag_value + ?chain_value]
    # [MaxOf ?cur_frag_value ?chain_value ?max]
    [set ?score = ?max]
    
    In ScoreFragment Frag ?frag Score ?score [Paragraph]
[end]
SearchAndScoreValidPaths ?frag ?score:
    [> ^CurDepth ^MaxDepth] # We're at the furthest we can go (base case)
    Base Case ?frag
    [Effects ?frag]
    [Value ?frag ?score]
[end]
SearchAndScoreValidPaths ?frag ?score:
    [Value ?frag ?score]
    Default ?frag
    [Paragraph]
[end]
# SearchAndScoreValidPaths ?frag ?score:
#     Error, unavailable fragment ?frag
# [end]

# This is the hard part
[predicate]
Value ?fragment ?value:
    [Fragment ?fragment ?scene] # get the scene
    [CompleteStorySpec ?scene]
    [= ?value ^MaxValue]
[end]
# Value not_on_the_path ?value: [= ?value 1]
# Value on_the_path ?value: [= ?value 2]
# Value hard ?value: [= ?value 3]
Value ?fragment ?value: [Fragment ?fragment ?scene] [= ?value 0]
