initially: 
    [set MaxDepth = 10]
[end]

# Exposed funcion headers
predicate AllPathsFrom ?source_frag ?paths.

[predicate]
AllPathsFrom ?source_frag ?paths: [FindPaths ?source_frag empty ?paths]

# Find all outgoing paths from ?frag and store them in the ^AllPaths global variable
# The wrapper for this Task is AllPathsFrom
# Example usage: [AllPathsFrom root ?paths]
# # Before running this, should reset ^AllPaths to empty
[predicate]
# TODO check additional unbound path case
FindPaths [?frag ?choice_id] ?path ?found_paths:
    [Length ?path ^MaxDepth]
    [ScorePath ?path ?scored_path]
    [= ?found_paths [?scored_path]]
[end]
FindPaths [?frag ?choice_id] ?path ?found_paths:
    [case ?frag] [Different root] : [Visit ?frag] [else] [end]
    [NotAny [AvailableNextFragment ?frag ?next_choice]]
    [ScorePath ?path ?scored_path]
    [= ?found_paths [?scored_path]]
[end]
FindPaths [?frag ?choice_id] ?path ?paths_from_children:
    [case ?frag] [Different root] : [Visit ?frag] [else]  [end]
    # All possible next fragments that can be selected are 'children' of the current fragment
    [FindUnique ?next_choice [AvailableNextFragment ?frag ?next_choice] ?potential_choices]
    [FindAll ?paths_from_child [FindAllPathsFromAChildOf ?potential_choices [?frag ?choice_id] ?path ?paths_from_child] ?list_of_paths_from_children]
    [Flatten2D ?list_of_paths_from_children ?paths_from_children]
[end]

[predicate]
FindAllPathsFromAChildOf ?choices ?current ?current_path ?paths_from_child:
    [Not [Length ?choices empty]]
    [Member ?child ?choices] # select a choice from the potential choices 
    [FindPathsForChild ?child ?current ?current_path ?paths_from_child]
[end]
[predicate]
FindPathsForChild ?child ?current ?current_path ?paths_from_child:
    # Construct the path to the child (not including the child)
    [Add ?current ?current_path ?child_path]       
    # Findall the paths from the child, store the result, and undo the state changes
    # This line does not Fail unless FindPaths fails
    [Backtrack [FindPaths ?child ?child_path] ?paths_from_child]
[end]

# Score a path
# Also reverse it to put make it a FIFO list (it arrives in reversed order)
ScorePath ?path ?scored_path: [Reverse ?path ?ordered_path] [ScoreCalculation ?ordered_path ?value] [ScoredPath ?ordered_path ?value ?scored_path]

## The data structure of a path that has been scored
ScoredPath ?path ?score ?scored_path: [= ?scored_path [?path ?score]] [Number ?score]

ScoreCalculation ?path ?value: 
    [LengthValue ?path ?length_value]
    [SatisfactionValue ?path ?satisfied_value] 
    [set ^Value = ?length_value + MaxDepth * ?satisfied_value] 
    [= ?value ^Value]
[end]

[predicate]
LengthValue ?path ?value:
    [Length ?path ?depth]
    [set ^Value = -?depth] [= ?value ^Value]
[end]

SatisfactionValue ?path ?value: [Length ?path 0] [= ?value 0]
SatisfactionValue ?path ?value: [WantsSatisfied ?value]

WantsSatisfied ?count:
    [FindAll ?want_id [FulfilledInScene ?want_id] ?satisfied_wants]
    [Length ?satisfied_wants ?count]
[end]

FulfilledInScene ?want_id:
    [Want ^CurrentScene ?want_id]
    [Fulfilled ?want_id]
[end]